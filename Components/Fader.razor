@using Diyokee
@inject IJSRuntime JS

<MouseSupport OnMouseEvent="@HandleMouseEvent">
    <div class="fader-container @(Enabled ? "" : "disabled")">
        <div class="name">@((MarkupString)Name)</div>
        <div class="fader @(Orientation == Orientations.Vertical ? "vertical" : "horizontal")" @ref="faderElement">
            <div class="knob button-thin"
                 style="@GetKnobCss()"
                 @ondblclick="() => SetValue(initialValue)">
            </div>
            <div class="range" style="@GetRangeCss()"></div>
        </div>
    </div>
</MouseSupport>

@code {
    public enum Orientations {
        Vertical,
        Horizontal
    }

    [Parameter]
    public Orientations Orientation { get; set; } = Orientations.Vertical;

    [Parameter]
    public double Value { get; set; } = 0.5;

    [Parameter]
    public double DefaultValue { get; set; } = 0.0;

    [Parameter]
    public string Name { get; set; } = "";

    [Parameter]
    public bool Enabled { get; set; } = true;

    [Parameter]
    public EventCallback<double> ValueChanged { get; set; }

    [CascadingParameter]
    private MouseState mouseState { get; set; } = default!;

    public bool EnableMouseEvents { get; set; } = true;

    private ElementReference faderElement;
    private double rangeTop = 0;
    private double rangeHeight = 0;
    private Bounds? faderBounds;
    private double faderSize = 0;
    private double gutterOffsetTop = 16;
    private double gutterOffsetBottom = 8;
    private double initialValue = 0.5;

    public void SetInitialValue(double value) {
        Value = value;
        initialValue = value;
        UpdateRange();
    }

    public async Task SetValue(double newValue, bool updateState = false) {
        newValue = Math.Clamp(newValue, 0, 1);

        if(Value == newValue) return;
        Value = newValue;
        UpdateRange();
        await ValueChanged.InvokeAsync(newValue);

        if(updateState) await InvokeAsync(StateHasChanged);
    }

    private void UpdateRange() {
        if(Value >= DefaultValue) {
            rangeTop = (1 - Value) * faderSize + gutterOffsetTop;
            rangeHeight = (Value - DefaultValue) * faderSize;
        } else {
            rangeTop = faderSize / 2 + gutterOffsetTop;
            rangeHeight = (DefaultValue - Value) * faderSize;
        }
    }

    private string GetKnobCss() {
        string prop = Orientation == Orientations.Vertical ? "top" : "left";
        return $"{prop}: calc(10px + 100% - {gutterOffsetTop + gutterOffsetBottom}px - (100% - {gutterOffsetTop + gutterOffsetBottom}px) * {Value})";
    }

    private string GetRangeCss() {
        string prop1 = Orientation == Orientations.Vertical ? "top" : "left";
        string prop2 = Orientation == Orientations.Vertical ? "height" : "width";
        return $"{prop1}: {rangeTop}px; {prop2}: {rangeHeight}px";
    }

    private async Task HandleMouseEvent() {
        if(Enabled) {
            double newValue = Orientation == Orientations.Vertical
                                ? 1.0 - (mouseState.Y - gutterOffsetTop - gutterOffsetBottom - faderBounds!.Y) / faderSize
                                : 1.0 - (mouseState.X - gutterOffsetTop - faderBounds!.X) / faderSize;
            newValue = Math.Clamp(newValue, 0, 1);
            await InvokeAsync(async () => {
                await SetValue(newValue);
                StateHasChanged();
            });
        }
    }

    [JSInvokable]
    public async Task OnResize() {
        faderBounds = new Bounds(await JS.InvokeAsync<double[]>("getElementBounds", faderElement));
        faderSize = (Orientation == Orientations.Vertical ? faderBounds.Height : faderBounds.Width) - gutterOffsetTop - gutterOffsetBottom;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender || faderBounds?.Width == 0 || faderBounds?.Height == 0) {
            switch(Orientation) {
                case Orientations.Vertical:
                    gutterOffsetTop = 16;
                    gutterOffsetBottom = 8;
                    break;
                case Orientations.Horizontal:
                    gutterOffsetTop = 16;
                    gutterOffsetBottom = 16;
                    break;
            }

            await OnResize();
            if(faderBounds?.Width == 0 || faderBounds?.Height == 0) {
                await Task.Run(async () => { // FIXME: Hacky way to wait for proper rendering (this only applies when using thre player inside a ModalDialog)
                    await Task.Delay(500);
                    await OnAfterRenderAsync(true);
                });
                return;
            }

            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("Diyokee.monitorResize", dotNetReference);

            UpdateRange();
            await InvokeAsync(StateHasChanged);
        }
    }
}
