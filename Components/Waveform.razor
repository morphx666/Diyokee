@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Diyokee
@using static Diyokee.DFile
@inject IJSRuntime JS

<MouseSupport OnMouseEvent="@HandleMouseEvent">
    <div class="waveform-container">
        <BECanvas Width="@canvasWidth" Height="@canvasHeight" @ref="canvas" />
        <div class="cursor" style="@GetCursorCss()"></div>
        @if(EnableZoomControls && Mode == Modes.AudioSynced) {
            <div class="zoom-controls">
                <div @onclick="() => Zoom(+1)"><i class="fa-solid fa-plus"></i></div>
                <div @onclick="() => Zoom(-1)"><i class="fa-solid fa-minus"></i></div>
            </div>
        }
    </div>
</MouseSupport>

@code {
    public enum Modes {
        AudioSynced,
        Full
    }

    private BECanvas? canvas;
    private Canvas2DContext? ctx;

    public bool IsMouseDown { get; internal set; } = false;

    private long canvasWidth = 0;
    private long canvasHeight = 0;
    private double canvasRatio = 1.0;
    private Bounds? canvasBounds;
    private Bounds? zoomControlsBounds;

    private long waveformId = 0;
    private long lastWaveformId = 0;
    private bool forceRenderWaveformFull = false;

    [Parameter]
    public string CssColor { get; set; } = "#444";

    public long PlaybackHead { get; set; }

    [Parameter]
    public Modes Mode { get; set; } = Modes.AudioSynced;

    [Parameter]
    public Player Player { get; set; } = null!;

    [Parameter]
    public bool BpmAwareScale { get; set; } = false;

    [Parameter]
    public bool EnableZoomControls { get; set; } = true;

    [CascadingParameter]
    private MouseState mouseState { get; set; } = null;

    public async Task Refresh() {
        await InvokeAsync(StateHasChanged);
    }

    public void UpdateFullWaveform() {
        waveformId = DateTime.Now.Ticks;
    }

    [JSInvokable]
    public async Task OnResize() {
        double[] canvasSize = (await JS.InvokeAsync<double[]>("resizeCanvas", canvas!.CanvasReference));
        canvasWidth = (long)canvasSize[0];
        canvasHeight = (long)canvasSize[1];
        canvasRatio = canvasSize[2];

        canvasBounds = new Bounds(await JS.InvokeAsync<double[]>("getElementBounds", canvas.CanvasReference));
        zoomControlsBounds = new(new double[] { // FIXME: This will fail if the browser is zoomed in/out
            canvasBounds.X + canvasWidth - 25,
            canvasBounds.Y,
            25,
            46
    });
        if(Mode == Modes.Full) forceRenderWaveformFull = true;
    }

    private async Task HandleMouseEvent() {
        IsMouseDown = mouseState.ButtonsDown == 0;
        if(!IsMouseDown) return;

        double sensitivity = 0.60;
        switch(Mode) {
            case Modes.AudioSynced:
                PlaybackHead -= (long)(mouseState.DeltaX * sensitivity);
                break;
            case Modes.Full:
                PlaybackHead = (long)((mouseState.X - canvasBounds!.X) * Player.WaveformWidth / canvasWidth);
                break;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender || canvasWidth == 0 || canvasHeight == 0) {
            await OnResize();
            if(canvasWidth == 0 || canvasHeight == 0) return;

            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("Diyokee.monitorResize", dotNetReference);
        }

        if((ctx = await canvas.CreateCanvas2DAsync()) != null) {
            try {
                switch(Mode) {
                    case Modes.AudioSynced:
                        await RenderWaveform();
                        break;
                    case Modes.Full:
                        if(forceRenderWaveformFull) {
                            forceRenderWaveformFull = false;
                            await RenderWaveformFull();
                        }
                        break;
                }
            } catch {
                // Just ignore it - this is usually caused by the beatMarkers collection being modified while rendering
                if(Mode == Modes.Full) forceRenderWaveformFull = true;
            }
        }
    }

    private string GetCursorCss() {
        if(Mode == Modes.AudioSynced) {
            return "";
        } else {
            if(Player.WaveformWidth == 0) return "display: none;";
            return $"left: {(double)PlaybackHead / Player.WaveformWidth * canvasWidth}px;";
        }
    }

    protected override void OnParametersSet() {
        if(waveformId != lastWaveformId) {
            lastWaveformId = waveformId;
            forceRenderWaveformFull = true;
        }

        base.OnParametersSet();
    }

    private async Task RenderWaveformFull() {
        double cw = canvasWidth / canvasRatio;
        double ch = canvasHeight / canvasRatio;
        double cw2 = canvasWidth / (canvasRatio * 2);
        double ch2 = canvasHeight / (canvasRatio * 2);

        await ctx!.BeginBatchAsync();
        await ctx.SetTransformAsync(canvasRatio, 0, 0, canvasRatio, 0, 0);
        await ctx.SetLineWidthAsync(1);
        await ctx.ClearRectAsync(0, 0, cw, ch);

        await ctx.SetFillStyleAsync("#000");
        await ctx.FillRectAsync(0, 0, cw, ch);

        await ctx.SetFillStyleAsync(CssColor);

        // Render waveform
        double lastX = -1;
        double step = cw / Player.Peaks.Length;
        double barWidth = step < 1 ? 1 : step - 1;
        for(int i = 0; i < Player.Peaks.Length; i++) {
            double x = i * step;
            if(lastX == x) continue;
            lastX = x;
            if(x < 0 || x >= cw) continue;
            double y = ch2 - Player.Peaks[i] / Player.MaxPeak * ch2;
            await ctx.FillRectAsync(x, y, barWidth, ch - y * 2);
        }

        // Render Cue Points
        await ctx.SetStrokeStyleAsync("#f92");
        foreach(CuePoint cp in Player.File?.CuePoints ?? []) {
            double x = cp.Position * Player.SecondsToPosX * step / Player.WaveformBarWidth;

            await ctx.MoveToAsync(x, 0);
            await ctx.LineToAsync(x, ch);
        }
        await ctx.StrokeAsync();

        await ctx.EndBatchAsync();
    }

    private async Task RenderWaveform() {
        if(Player is null) return;

        double tempoFactor = BpmAwareScale ? Player.ReScaleTempoFader() + 1.0 : 1.0;
        double wfw = Player.WaveformBarWidth / tempoFactor;
        double pbh = PlaybackHead / tempoFactor;

        double cw = canvasWidth / canvasRatio;
        double ch = canvasHeight / canvasRatio;
        double cw2 = canvasWidth / (canvasRatio * 2);
        double ch2 = canvasHeight / (canvasRatio * 2);

        await ctx!.BeginBatchAsync();
        await ctx.SetTransformAsync(canvasRatio, 0, 0, canvasRatio, 0, 0);
        await ctx.SetLineWidthAsync(1);
        await ctx.ClearRectAsync(0, 0, cw, ch);

        await ctx.SetFillStyleAsync("#000");
        await ctx.FillRectAsync(0, 0, cw, ch);

        await ctx.BeginPathAsync();
        await ctx.SetStrokeStyleAsync("#ccc");
        await ctx.MoveToAsync(0, ch2);
        await ctx.LineToAsync(cw, ch2);
        await ctx.StrokeAsync();


        // Render waveform
        await ctx.SetFillStyleAsync(CssColor);
        for(int i = (int)Math.Max(0, (pbh - cw2) / wfw - 1); i < Player.Peaks.Length; i++) {
            double x = i * wfw + cw2 - pbh;
            if(x >= cw) break;
            double y = ch2 - Player.Peaks[i] / Player.MaxPeak * ch2;
            await ctx.FillRectAsync(x, y, wfw - 1, ch - y * 2);
        }

        // Render beat markers
        if(Player.File != null) {
            await ctx.BeginPathAsync();
            await ctx.SetStrokeStyleAsync("#888");
            Player.BeatMarkers.ForEach(async beatMarker => {
                double x = beatMarker.X / tempoFactor + cw2 - pbh;
                if(x >= 0 && x < cw) {
                    await ctx.MoveToAsync(x, 0);
                    await ctx.LineToAsync(x, ch);
                }
            });
            await ctx.StrokeAsync();

            // Render downbeat marker
            await ctx.BeginPathAsync();
            await ctx.SetStrokeStyleAsync("#2ef");
            await ctx.MoveToAsync(Player.File.DownbeatAt * Player.SecondsToPosX + cw2 - pbh, 0);
            await ctx.LineToAsync(Player.File.DownbeatAt * Player.SecondsToPosX + cw2 - pbh, ch);
            await ctx.StrokeAsync();
        }

        // Render loop
        if(Player.Loop.Enabled) {
            double x1 = Player.Loop.Start * Player.SecondsToPosX / tempoFactor + cw2 - pbh;
            double x2 = Player.Loop.End * Player.SecondsToPosX / tempoFactor + cw2 - pbh;

            if(x1 >= 0 || x1 <= cw || x2 >= 0 || x2 <= cw) { // Render the loop if it's partially visible
                await ctx.SetFillStyleAsync(CssColor + "55");
                await ctx.FillRectAsync(x1, 0, x2 - x1, ch);
            }
        }

        // Render Cue Points
        const int heightHack = 12;
        await ctx.SetStrokeStyleAsync("#f92");
        foreach(CuePoint cp in Player.File?.CuePoints ?? []) {
            double p = 2; // Padding
            double x = cp.Position * Player.SecondsToPosX / tempoFactor + cw2 - pbh + 0.5; // FIXME: Again with +0.5 ??? Why?

            var textMetrics = await ctx.MeasureTextAsync(cp.Name);
            if(x >= -textMetrics.Width && x < cw) {
                await ctx.BeginPathAsync();

                await ctx.SetFillStyleAsync("#f92");
                await ctx.FillRectAsync(x, p, textMetrics.Width + 4 * p, heightHack + p);
                await ctx.SetFillStyleAsync("#000");
                await ctx.FillTextAsync(cp.Name, x + p, 10 + p);

                await ctx.MoveToAsync(x, 0);
                await ctx.LineToAsync(x, ch);
                await ctx.StrokeAsync();
            }
        }

        await ctx.EndBatchAsync();
    }

    private void Zoom(int factor) {
        Player.WaveformBarWidth += factor;
        if(Player.WaveformBarWidth < 2) Player.WaveformBarWidth = 2;
        if(Player.WaveformBarWidth > 10) Player.WaveformBarWidth = 10;
        Player.SetParameters();

        if(!Player.MinimalMode) {
            Program.Settings.Playback.WaveformZoom = Player.WaveformBarWidth;
        }
    }
}
