@using Diyokee
@inject IJSRuntime JS

<div class="container" @ref="knobElement" @ondblclick="() => SetValue(initialValue)">
    <div class="knob-container @(Enabled ? "" : "disabled")">
        <div class="knob">
            <div class="range" style="@GetRangeCss()"></div>
            <div class="pointer" style="@GetPointerCss()"></div>
        </div>
    </div>
    <div class="name">@Name</div>
</div>

@code {
    [Parameter]
    public string Name { get; set; } = "Mid";

    [Parameter]
    public double Value { get; set; } = 0.5;

    [Parameter]
    public EventCallback<double> ValueChanged { get; set; }

    [CascadingParameter]
    private MouseState? mouseState { get; set; } = null;

    [Parameter]
    public bool Enabled { get; set; } = true;

    [Parameter]
    public bool RangeFromCenter { get; set; } = true;

    public bool EnableMouseEvents { get; set; } = true;

    private ElementReference knobElement;
    private Bounds? knobBounds;
    private double knobSize = 0;
    private double initialValue = 0.5;
    private const double minAngle = 1.08;
    private double angleRange = 135.0; // Degrees from center to min/max

    public void SetInitialValue(double value) {
        Value = value;
        initialValue = value;
    }

    public async Task SetValue(double newValue, bool updateState = false) {
        if(Value == newValue) return;
        Value = newValue;
        await ValueChanged.InvokeAsync(newValue);

        if(updateState) await InvokeAsync(StateHasChanged);
    }

    public string GetPointerCss() {
        double angle = (Value - 0) * (angleRange - (-angleRange)) / (1 - 0) + (-angleRange);
        return $"transform: rotate({angle}deg)";
    }

    public string GetRangeCss() {
        double angle = (Value - 0) * (angleRange - (-angleRange)) / (1 - 0) + (-angleRange);
        if(RangeFromCenter) {
            if(angle < 0) {
                angle += 360;
                return $"background: conic-gradient(var(--app-background-color) 0deg {angle}deg, var(--ctrl-highlight-soft) {angle}deg);";
            } else {
                return $"background: conic-gradient(var(--ctrl-highlight-soft) 0deg {angle}deg, var(--app-background-color) {angle}deg);";
            }
        } else {
            double rangeStart = 360.0 - angleRange;
            if(angle < 0) {
                angle += 360;
                return $"background: conic-gradient(var(--app-background-color) 0deg {rangeStart}deg, var(--ctrl-highlight-soft) {rangeStart}deg {angle}deg, var(--app-background-color) {angle}deg);";
            } else {
                return $"background: conic-gradient(var(--ctrl-highlight-soft) 0 {angle}deg, var(--app-background-color) {angle}deg {rangeStart}deg, var(--ctrl-highlight-soft) {rangeStart}deg 0deg);";
            }
        }
    }

    [JSInvokable]
    public async Task OnResize() {
        knobBounds = new Bounds(await JS.InvokeAsync<double[]>("getElementBounds", knobElement));
        knobSize = knobBounds.Height;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender || knobBounds?.Width == 0 || knobBounds?.Height == 0) {
            await OnResize();
            if(knobBounds?.Width == 0 || knobBounds?.Height == 0) return;

            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("Diyokee.monitorResize", dotNetReference);

            await Task.Run(async () => {
                bool isValid = false;
                int delay = 60;
                while(true) {
                    await Task.Delay(delay);
                    if(!EnableMouseEvents || !Enabled) continue;

                    if(!isValid
                        && knobBounds != null
                        && (!mouseState?.IsCaptured ?? false)
                        && mouseState?.ButtonsDown == 1
                        && knobBounds.Contains(mouseState.X, mouseState.Y)) {
                        mouseState.IsCaptured = true;
                        isValid = true;
                    }

                    if(isValid) {
                        if(mouseState?.ButtonsDown == 1) {
                            double offset = mouseState.Y - knobBounds!.Y;
                            double newValue = (knobSize - offset) / knobSize;
                            newValue = Math.Clamp(newValue, 0, 1);
                            await InvokeAsync(async () => {
                                await SetValue(newValue);
                                StateHasChanged();
                            });
                        } else {
                            mouseState!.IsCaptured = false;
                            isValid = false;
                        }
                    } else if(mouseState?.WheelDelta != 0 && knobBounds!.Contains(mouseState!.X, mouseState.Y)) {
                        double newValue = Value - (mouseState.WheelDelta / 2_000);
                        newValue = Math.Clamp(newValue, 0, 1);
                        await InvokeAsync(async () => {
                            await SetValue(newValue);
                            StateHasChanged();
                        });

                        mouseState.WheelDelta = 0;
                    }
                }
            });

            await InvokeAsync(StateHasChanged);
        }
    }
}
