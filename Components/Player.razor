@using System.Diagnostics
@using System.Drawing
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Diyokee
@using Un4seen.Bass
@using Un4seen.Bass.AddOn.Fx
@using Un4seen.Bass.AddOn.Mix
@using static Diyokee.Settings
@inject IJSRuntime JS

<div class="player-container">
    @if(!MinimalMode) {
        <div class="header">
            <div class="file-info ellipsis">
                <span class="ellipsis">@file?.Title</span>
                <span class="ellipsis">@file?.Artist</span>
                <span class="ellipsis">@file?.Album</span>
            </div>
            <div class="time">
                <span>@DFile.FormatTime(playbackPosition)</span>
                <span>-@DFile.FormatTime(GetRemainingTime())</span>
                <span>&nbsp;</span>
            </div>
            <div class="bpm-key">
                <span>@CalcBpm()</span>
                <span>@GetBpmAdjustment()</span>
                <span>&nbsp;@keyTools.ConvertTo(file?.Key ?? "", KeyTools.Notations.CamelotKey)</span>
            </div>
            <div class="player-name" style="background-color: @Settings.Color">
                @Settings.Name
            </div>
        </div>
    }

    <div class="waveform-full">
        <Waveform CssColor="@Settings.Color"
            Mode="Waveform.Modes.Full"
            BeatMarkers="@beatMarkers"
            DownbeatAt="@(file?.DownbeatAt ?? -1)"
            MaxPeak="@maxPeak"
            Peaks="@peaks"
            SecondsToPosX="@secondsToPosX"
            WaveformBarWidth="@waveformBarWidth"
            WaveformWidth="@waveformWidth"
            @ref="waveformFull" />
    </div>

    <div class="waveform">
        <Waveform CssColor="@Settings.Color"
            Mode="Waveform.Modes.AudioSynced"
            BeatMarkers="@beatMarkers"
            DownbeatAt="@(file?.DownbeatAt ?? -1)"
            MaxPeak="@maxPeak"
            Peaks="@peaks"
            SecondsToPosX="@secondsToPosX"
            WaveformBarWidth="@waveformBarWidth"
            WaveformWidth="@waveformWidth"
            Loop="loop"
            @ref="waveform" />

        <VuMeter @ref="vuMeter" />
        <Fader Orientation="Fader.Orientations.Vertical" ValueChanged="ApplyVolume" Name="<i class='fa-solid fa-volume-high'></i>" DefaultValue="0" @ref="faderVolume" />

        @if(!MinimalMode) {
            <Fader Orientation="Fader.Orientations.Vertical" ValueChanged="ApplyTempo" Name="<i class='fa-solid fa-music'></i>" DefaultValue="0.5" @ref="faderTempo" />
            <Eq ValueChanged="ApplyEqValues" EqProfileChanged="EqProfileChanged" @ref="EqControls" />
        }
    </div>

    <div class="transport">
        <div class="button-3d icon led @(IsPlaying ? "green" : "")" @onmouseup="(e) => HandlePlayClick(e, Program.Settings.Playback.SyncPlayback)"><i class="fa-solid fa-play"></i></div>
        <div class="button-3d icon" @onmouseup="HandleStopClick"><i class="fa-solid fa-stop"></i></div>
        <div class="button-3d icon"
            @onmousedown="(e) => HandlePlayClick(e, false)"
            @onmouseup="HandleStopAndSnapClick">
            <i class="fa-solid fa-forward-step"></i>
        </div>
        <div class="button-3d icon" @onmouseup="HandleSnapToClosestBeatMarker"><i class="fa-solid fa-down-left-and-up-right-to-center fa-rotate-by" style="--fa-rotate-angle: 45deg;"></i></div>
        @if(!MinimalMode) {
            <div class="button-3d icon" @onmouseup="HandleRequestedFileCue"><i class="fa-solid fa-eject"></i></div>
            <div class="button-3d icon" @onmouseup="HandleSyncBPMToOtherPlayer"><i class="fa-solid fa-arrow-right-from-bracket"></i> @(OtherPlayer?.Settings.Name ?? "")</div>
            <div class="sync-adjust">
                <span>SYNC</span>
                <div class="sync-buttons">
                    <div class="button-3d" @onmousedown="SlowDown" @onmouseup="ResetSpeed"><i class="fa-solid fa-left-long"></i></div>
                    <div class="button-3d" @onmousedown="SpeedUp" @onmouseup="ResetSpeed"><i class="fa-solid fa-right-long"></i></div>
                </div>
            </div>
        }
    </div>

    @if(!MinimalMode) {
        <div class="loop-container">
            <div class="button-thin led @(loop.Enabled ? "green" : "")" @onclick="ToggleLoop">Loop</div>
            <div class="loop-size-container">
                @foreach(var size in loopSizes) {
                    <div
                        class="button @(loopSize == size.Item2 ? "selected" : "")"
                        @onclick="() => SetLoopSize(size.Item2, false)">
                        @size.Item1
                    </div>
                }
            </div>
            <div class="button-thin no-click">Jump</div>
            <div class="loop-size-container">
                @foreach(var size in loopSizes) {
                    <div
                        class="button @(jumpSize == size.Item2 ? "selected" : "")"
                        @onclick="() => SetJumpSize(size.Item2)">
                        @size.Item1
                    </div>
                }

                <div class="jump-buttons">
                    <div class="button-thin" @onclick="() => DoJump(-1)"><i class="fa-solid fa-caret-left"></i></div>
                    <div class="button-thin" @onclick="() => DoJump(+1)"><i class="fa-solid fa-caret-right"></i></div>
                </div>
            </div>
            <div class="lock-button"><i class="fa-solid @(loopJumpLock ? "fa-lock" : "fa-lock-open")" @onclick="ToggleLoopJumpSync"></i></div>
        </div>
    }
</div>

@code {
    private int streamHandle = 0;
    private int fxHandle = 0;
    private int eqHandle = 0;
    private BASS_BFX_PEAKEQ eqParams = new();
    private string lastFilename = "";

    private double trackGain = 1;
    private double crossFaderVolume = 1;

    private DFile? file = null;
    private Fader? faderVolume;
    private Fader? faderTempo;
    private Waveform? waveform;
    private Waveform? waveformFull;
    private VuMeter? vuMeter;
    public Eq EqControls = null!;

    private double fileBPM = 0;
    private const int waveformBarWidth = 5;
    private int waveformWidth = 0;
    private long trackLengthBytes = 0;
    private double playbackPosition = 0;
    private long waveformStepLength = 0;
    private bool queueAutoSnap = false;
    private double[] peaks = [];
    private double maxPeak = 1.0;
    private double beatsPerSecond;
    private double secondsToPosX;
    private double currentTempoValue;

    private Loop loop = new();
    private (string, double)[] loopSizes = {
        ("¼", 0.25),
        ("½", 0.50),
        ("1", 1.00),
        ("2", 2.00),
        ("4", 4.00),
        ("8", 8.00),
        ("16", 16.00),
        ("32", 32.00)
    };
    private double loopSize = 8.0;
    private double jumpSize = 8.0;
    private bool loopJumpLock = true;

    private List<(double X, double Seconds)> beatMarkers = new();
    private double cuePoint = 0;

    private KeyTools keyTools = new();

    private bool IsPlaying { get; set; }

    [Parameter]
    public DFile? File { // TODO: Apply the same logic as in FilesUI
        get => file;
        set {
            if(value != null && lastFilename != value.Filename) {
                if(IsPlaying && Program.Settings.Playback.LockOnPlay) return;

                lastFilename = value.Filename;
                file = value;
                Stop(false);
                LoadFile();
            }
        }
    }

    [Parameter]
    public EventCallback RequestedFileCue { get; set; }

    [Parameter]
    public PlayerSettings Settings { get; set; } = null!;

    [Parameter]
    public Player? OtherPlayer { get; set; } = null;

    [Parameter]
    public bool MinimalMode { get; set; } = false;

    public bool InBeat { get; set; } = false;

    private bool enableMouseEvents = true;
    public bool EnableMouseEvents {
        get => enableMouseEvents;
        set {
            enableMouseEvents = value;
            if(!MinimalMode) {
                EqControls.EnableMouseEvents = value;
                faderTempo!.EnableMouseEvents = value;
            }
            faderVolume!.EnableMouseEvents = value;
            waveform!.EnableMouseEvents = value;
            waveformFull!.EnableMouseEvents = value;
        }
    }

    public Player() {
        Task.Run(MonitorPlayback);
        Task.Run(MonitorBeats);
    }

    public void SetFile(DFile file, bool fullReset = true) {
        if(fullReset) {
            File = file;
        } else {
            this.file = file;
            SetParameters();
            SetLoopSize(loopSize, false);
        }
    }

    public void SetCrossFaderVolume(double value) {
        crossFaderVolume = value;
        ApplyVolume(faderVolume?.Value ?? 0);
    }

    public async void SyncBPMToOtherPlayer() {
        if(OtherPlayer?.File == null || fileBPM == 0) return;

        double tempo = (OtherPlayer?.AdjustedBPM ?? 0) / fileBPM * 1.5 - 1.0;
        await faderTempo!.SetValue(tempo);
    }

    private void HandlePlayClick(MouseEventArgs e, bool autoSync) {
        if(e.Button == 0) Play(autoSync);
    }

    private void HandleStopClick(MouseEventArgs e) {
        if(e.Button == 0) Stop(false);
    }

    private void HandleStopAndSnapClick(MouseEventArgs e) {
        if(e.Button == 0) Stop(true);
    }

    private void HandleSnapToClosestBeatMarker(MouseEventArgs e) {
        if(e.Button == 0) SnapToClosestBeatMarker();
    }

    private void HandleRequestedFileCue(MouseEventArgs e) {
        if(e.Button == 0) RequestedFileCue.InvokeAsync();
    }

    private void HandleSyncBPMToOtherPlayer(MouseEventArgs e) {
        if(e.Button == 0) SyncBPMToOtherPlayer();
    }

    public void Play(bool autoSync) {
        if(fxHandle == 0) return;
        if(IsPlaying) {
            BassMix.BASS_Mixer_ChannelPause(fxHandle);
            IsPlaying = false;
        } else {
            if(autoSync && (OtherPlayer?.IsPlaying ?? false)) {
                Task.Run(async () => { // TODO: This should be optional
                    while(true) {
                        await Task.Delay(1);
                        if(OtherPlayer.InBeat) {
                            long p = BassMix.BASS_Mixer_ChannelGetPosition(fxHandle);
                            long offset = Bass.BASS_ChannelSeconds2Bytes(streamHandle, (1 / beatsPerSecond) / 10);
                            BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, p + offset);

                            BassMix.BASS_Mixer_ChannelPlay(fxHandle);
                            IsPlaying = true;
                            break;
                        }
                    }
                });
            } else {
                BassMix.BASS_Mixer_ChannelPlay(fxHandle);
                IsPlaying = true;
            }
        }
    }

    public void Stop(bool resetToCuePoint) {
        if(fxHandle == 0) return;
        BassMix.BASS_Mixer_ChannelPause(fxHandle);
        BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, Bass.BASS_ChannelSeconds2Bytes(fxHandle, resetToCuePoint ? cuePoint : 0));
        IsPlaying = false;
    }

    private void ApplyVolume(double value) {
        if(fxHandle == 0) return;
        Bass.BASS_ChannelSetAttribute(fxHandle, BASSAttribute.BASS_ATTRIB_VOL, (float)(trackGain * value * crossFaderVolume));
    }

    private void ApplyTempo() {
        if(fxHandle == 0) return;
        // tempo = ((1 + X) / 1.5 - 1) * 100
        // X = (tempo / 100 * 1.5) - 1
        double tempo = ((1.0 + (faderTempo?.Value ?? 0.5)) / 1.5 - 1.0) * 100.0;

        Bass.BASS_ChannelSetAttribute(fxHandle, BASSAttribute.BASS_ATTRIB_TEMPO, (float)tempo);
        if(Program.Settings.Playback.SyncPlayersBpm) {
            // FIXME: Implement to login to avoid recursion
            //OtherPlayer?.SyncBPMToOtherPlayer();
        }
    }

    private void ApplyEqValues(Eq.EqValues eqValues) {
        // Lo
        eqParams.lBand = 0;
        eqParams.fCenter = EqControls.EqProfile.Low;
        eqParams.fGain = (float)(eqValues.Lo * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // Mid
        eqParams.lBand = 1;
        eqParams.fCenter = EqControls.EqProfile.Mid;
        eqParams.fGain = (float)(eqValues.Mid * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // Hi
        eqParams.lBand = 2;
        eqParams.fCenter = EqControls.EqProfile.Hi;
        eqParams.fGain = (float)(eqValues.Hi * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

    }

    private void EqProfileChanged(EqualizerProfile eqProfile) {
        if(OtherPlayer != null) OtherPlayer.EqControls.EqProfile = eqProfile;
        UpdateSettings();
    }

    private string CalcBpm() {
        double bpm = (file?.BPM ?? 0) * (1.0 + (faderTempo?.Value ?? 0)) / 1.5;
        return bpm.ToString("N2");
    }

    private string GetBpmAdjustment() {
        double bpm = fileBPM * (1.0 + (faderTempo?.Value ?? 0)) / 1.5;
        double adjustment = bpm > 0 ? 100.0 - fileBPM / bpm * 100.0 : 0;
        return $"{(adjustment > 0 ? "+" : "")}{adjustment:N2}%";
    }

    private double GetRemainingTime() {
        if(file?.Duration > 0) return (file?.Duration - playbackPosition) ?? 0;
        return 0;
    }

    private double AdjustedBPM {
        get => fileBPM * (1.0 + (faderTempo?.Value ?? 0)) / 1.5;
    }

    private void SlowDown(MouseEventArgs e) {
        if(e.Button == 0) {
            currentTempoValue = faderTempo!.Value;
            faderTempo?.SetValue(faderTempo.Value - 0.1);
        }
    }

    private void SpeedUp(MouseEventArgs e) {
        if(e.Button == 0) {
            currentTempoValue = faderTempo!.Value;
            faderTempo?.SetValue(faderTempo.Value + 0.1);
        }
    }

    private void ResetSpeed(MouseEventArgs e) {
        if(e.Button == 0) faderTempo?.SetValue(currentTempoValue);
    }

    private void LoadFile() {
        IsPlaying = false;

        if(streamHandle != 0) {
            BassMix.BASS_Mixer_ChannelRemove(streamHandle);
            Bass.BASS_ChannelStop(streamHandle);
            Bass.BASS_StreamFree(streamHandle);
            streamHandle = 0;
        }

        if(file == null || faderVolume == null) return;

        streamHandle = Bass.BASS_StreamCreateFile(file.Filename, 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_STREAM_PRESCAN | BASSFlag.BASS_ASYNCFILE);
        BASSError bassErrorCode = Bass.BASS_ErrorGetCode();
        if(streamHandle == 0 || bassErrorCode != BASSError.BASS_OK) {
            // TODO: Do something so the user knows the file cannot be played
        }
        fxHandle = BassFx.BASS_FX_TempoCreate(streamHandle, BASSFlag.BASS_FX_TEMPO_ALGO_SHANNON | BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_FX_FREESOURCE);
        BassMix.BASS_Mixer_StreamAddChannel(Program.BassMixHandle, fxHandle, BASSFlag.BASS_MIXER_CHAN_PAUSE | BASSFlag.BASS_MIXER_CHAN_NORAMPIN | BASSFlag.BASS_MIXER_CHAN_BUFFER);
        trackGain = Math.Pow(10, (file.HasReplayGain ? file.ReplayGain : -2) / 20.0);

        ApplyVolume(faderVolume!.Value);
        SetupEQ();
        faderTempo?.SetValue(0.5);
        if(loop.Enabled) ToggleLoop();

        trackLengthBytes = Bass.BASS_ChannelGetLength(streamHandle, BASSMode.BASS_POS_BYTE);
        waveformStepLength = Bass.BASS_ChannelSeconds2Bytes(streamHandle, FilesUI.TimeSlice);

        // peaks = [];
        // beatMarkers.Clear();
        Task.Run(async () => {
            while(!SetParameters()) await Task.Delay(1000);
            queueAutoSnap = !IsPlaying;
        });
    }

    private void SetupEQ() {
        if(EqControls == null) return;
        // set peaking equalizer effect with no bands
        eqHandle = Bass.BASS_ChannelSetFX(fxHandle, BASSFXType.BASS_FX_BFX_PEAKEQ, 0);

        // setup the EQ bands
        eqParams.fQ = 0f;
        eqParams.fBandwidth = 2.5f;
        eqParams.lChannel = BASSFXChan.BASS_BFX_CHANALL;

        // create 1st band for bass
        eqParams.lBand = 0;
        eqParams.fCenter = EqControls.EqProfile.Low;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // create 2nd band for mid
        eqParams.lBand = 1;
        eqParams.fCenter = EqControls.EqProfile.Mid;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // create 3rd band for treble
        eqParams.lBand = 2;
        eqParams.fCenter = EqControls.EqProfile.Hi;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        EqControls?.Reset();
    }

    public bool SetParameters() {
        peaks = [];
        beatMarkers.Clear();
        waveformFull?.UpdateFullWaveform();

        if(file == null || !file.WaveformUnZipped.Contains('|')) return false;

        peaks = file.WaveformUnZipped.Split('|').Select(p => double.Parse(p)).ToArray();
        maxPeak = peaks.Max();

        waveformWidth = peaks.Length * waveformBarWidth;
        beatsPerSecond = file!.BPM / 60.0;
        secondsToPosX = 1.0 / (file.Duration == 0 ? 1 : file.Duration) * waveformWidth;

        fileBPM = file.BPM;

        // x = s / file.Duration * waveformWidth
        // s = x / waveformWidth * file.Duration

        GenerateBeatMarkers();
        waveformFull?.UpdateFullWaveform();

        return true;
    }

    private void GenerateBeatMarkers() {
        if(file!.DownbeatAt == -1) return;

        double t1 = file.DownbeatAt;
        double t2 = t1 - 1 / beatsPerSecond;
        while(t1 < file.Duration || t2 >= 0) {
            if(t1 < file.Duration) {
                beatMarkers.Add((t1 * secondsToPosX, t1));
                t1 += 1 / beatsPerSecond;
            }
            if(t2 >= 0) {
                beatMarkers.Insert(0, (t2 * secondsToPosX, t2));
                t2 -= 1 / beatsPerSecond;
            }
        }
    }

    private void SnapToClosestBeatMarker() {
        if(beatMarkers.Count == 0) return;
        double playbackPositionSeconds = Bass.BASS_ChannelBytes2Seconds(streamHandle, BassMix.BASS_Mixer_ChannelGetPosition(fxHandle));

        int closestIndex = 0;
        double closestDistance = float.MaxValue;
        for(int i = 0; i < beatMarkers.Count; i++) {
            double distance = Math.Abs(beatMarkers[i].Seconds - playbackPositionSeconds);
            if(distance < closestDistance) {
                closestDistance = distance;
                closestIndex = i;
            }
        }

        double seconds = beatMarkers[closestIndex].Seconds;
        cuePoint = seconds;
        BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, Bass.BASS_ChannelSeconds2Bytes(fxHandle, cuePoint));
    }

    private void ToggleLoop() {
        if(file == null) return;
        loop.Enabled = !loop.Enabled;
        SetLoopSize(loopSize, true);
    }

    private SYNCPROC loopSyncProc = null!;
    private void SetLoopSize(double size, bool resetStart) {
        loopSize = size;
        if(loopJumpLock) jumpSize = loopSize;
        UpdateSettings();

        double position = Bass.BASS_ChannelBytes2Seconds(fxHandle, BassMix.BASS_Mixer_ChannelGetPosition(fxHandle));
        if(resetStart) loop.Start = position;
        this.loop.End = loop.Start + loopSize / beatsPerSecond;

        if(loop.BASSHandle != 0) {
            Bass.BASS_ChannelRemoveSync(fxHandle, loop.BASSHandle);
            loop.BASSHandle = 0;
        } else if(loopSyncProc == null) loopSyncProc = new SYNCPROC(DoLoop);

        if(loop.Enabled) {
            loop.StartBytes = Bass.BASS_ChannelSeconds2Bytes(fxHandle, loop.Start);
            loop.EndBytes = Bass.BASS_ChannelSeconds2Bytes(fxHandle, loop.End);

            if(loop.EndBytes > trackLengthBytes) {
                loop.Enabled = false;
                return;
            }

            Bass.BASS_ChannelLock(fxHandle, true);
            loop.BASSHandle = Bass.BASS_ChannelSetSync(fxHandle, BASSSync.BASS_SYNC_POS | BASSSync.BASS_SYNC_MIXTIME, loop.EndBytes, loopSyncProc, IntPtr.Zero);
            Bass.BASS_ChannelLock(fxHandle, false);
        }
    }

    private void SetJumpSize(double size) {
        if(loopJumpLock) {
            SetLoopSize(size, false);
        } else {
            jumpSize = size;
        }
        UpdateSettings();
    }

    private void ToggleLoopJumpSync() {
        loopJumpLock = !loopJumpLock;
        if(loopJumpLock) jumpSize = loopSize;
        UpdateSettings();
    }

    private void UpdateSettings() {
        Settings.LoopJumpLock = loopJumpLock;
        Settings.LoopSize = loopSize;
        Settings.JumpSize = jumpSize;
        Program.Settings.Playback.EqProfile = EqControls.EqProfile.Name;
    }

    private void DoLoop(int handle, int channel, int data, IntPtr user) {
        if(loop.Enabled) BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, loop.StartBytes);
    }

    private void DoJump(int direction) {
        long p = BassMix.BASS_Mixer_ChannelGetPosition(fxHandle);
        long offset = p + direction * Bass.BASS_ChannelSeconds2Bytes(fxHandle, jumpSize / beatsPerSecond);
        if(offset > trackLengthBytes) return;
        if(offset < 0) offset = 0;

        // FIXME: This doesn't work correctly while playing; may have to ask Ian about it ;)
        BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, offset, BASSMode.BASS_POS_MIXER_RESET | BASSMode.BASS_MIXER_CHAN_NORAMPIN);
    }

    private async Task MonitorBeats() {
        double threshold = 0.01;
        bool beatFlag = false;
        bool lastInBeat = false;
        bool checkFlag = true;
        int interval = 0;
        while(true) {
            await Task.Delay(1);

            if(IsPlaying) {
                playbackPosition = Bass.BASS_ChannelBytes2Seconds(fxHandle, BassMix.BASS_Mixer_ChannelGetPosition(fxHandle));

                double beatsInterval = 1 / beatsPerSecond;
                double d = playbackPosition / beatsInterval;
                double fp = d - Math.Floor(d);
                bool inBeat = fp < threshold;

                if(inBeat && checkFlag) {
                    beatFlag = !beatFlag;
                    lastInBeat = inBeat;
                    checkFlag = false;
                    this.InBeat = beatFlag;
                } else if(!inBeat && !checkFlag) {
                    checkFlag = true;
                }

                if(++interval > 30) {
                    float[] levelsReal = BassMix.BASS_Mixer_ChannelGetLevel(handle: fxHandle, flags: BASSLevel.BASS_LEVEL_MONO);
                    float[] levelsMonitor = BassMix.BASS_Mixer_ChannelGetLevel(handle: fxHandle, flags: BASSLevel.BASS_LEVEL_MONO | BASSLevel.BASS_LEVEL_VOLPAN);

                    vuMeter?.SetLevel(levelsReal[0], levelsMonitor[0], beatFlag ? 2 : 1);

                    interval = 0;
                }
            }
        }
    }

    private async Task MonitorPlayback() {
        int intervals = 0;
        int delay = 60;
        while(true) {
            await Task.Delay(delay);

            if(Bass.BASS_ChannelIsActive(fxHandle) == BASSActive.BASS_ACTIVE_PLAYING) {
                if(waveform!.IsMouseDown) {
                    long p = waveform.PlaybackHead * waveformStepLength / waveformBarWidth;
                    BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, p);
                } else if(waveformFull!.IsMouseDown) {
                    long p = waveformFull.PlaybackHead * waveformStepLength / waveformBarWidth;
                    BassMix.BASS_Mixer_ChannelSetPosition(fxHandle, p);
                } else {
                    waveform.PlaybackHead = BassMix.BASS_Mixer_ChannelGetPosition(fxHandle) * waveformBarWidth / waveformStepLength;
                    waveformFull.PlaybackHead = waveform.PlaybackHead;
                }
                //playbackPosition = Bass.BASS_ChannelBytes2Seconds(fxHandle, BassMix.BASS_Mixer_ChannelGetPosition(fxHandle));

                // float[] levelsReal = BassMix.BASS_Mixer_ChannelGetLevel(handle: fxHandle, flags: BASSLevel.BASS_LEVEL_MONO);
                // float[] levelsMonitor = BassMix.BASS_Mixer_ChannelGetLevel(handle: fxHandle, flags: BASSLevel.BASS_LEVEL_MONO | BASSLevel.BASS_LEVEL_VOLPAN);
                // if(levelsReal != null && levelsMonitor != null) {
                //     vuMeter?.SetLevel(levelsReal[0], levelsMonitor[0], 0);
                // }

                await waveform.Refresh();
                if(intervals % 5 == 0) await waveformFull!.Refresh();
            }

            if(++intervals % 12 == 0) await InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender && faderVolume != null && (faderTempo != null || MinimalMode)) {
            faderVolume!.SetInitialValue(0.8);
            if(!MinimalMode) {
                faderTempo.SetInitialValue(0.5);
                EqControls.EqProfile = Program.Settings.EqualizerProfiles.FirstOrDefault(p => p.Name == Program.Settings.Playback.EqProfile) ?? Program.Settings.EqualizerProfiles[0];
                loopJumpLock = Settings.LoopJumpLock;
            }
            await InvokeAsync(StateHasChanged);
        }

        if(queueAutoSnap) {
            SnapToClosestBeatMarker();
            queueAutoSnap = false;
        }
    }
}
