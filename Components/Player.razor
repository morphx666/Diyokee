@using System.Drawing
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Diyokee
@using System.Runtime.InteropServices
@using Newtonsoft.Json
@using System.ComponentModel
@using System.Threading.Tasks
@using System.Diagnostics
@using Un4seen.Bass
@using Un4seen.Bass.AddOn.Fx
@using Un4seen.Bass.AddOn.Mix
@using static Diyokee.DFile
@using static Diyokee.Settings
@inject IJSRuntime JS
@inject SessionState session

<div class="player-container"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault="true"
     @ondrop="HandleDrop"
     @ondragenter="HandleDragEnter"
     @ondragleave="HandleDragLeave">
    @if(!MinimalMode) {
        <div class="header">
            <div class="file-info ellipsis">
                <span class="ellipsis">@File?.Title</span>
                <span class="ellipsis">@File?.Artist</span>
                <span class="ellipsis">@File?.Album</span>
            </div>
            <div class="time-bpm-key">
                <div class="time-bpm">
                    <div class="time">
                        <span>@DFile.FormatTime(playbackPosition)</span>
                        <span>-@DFile.FormatTime(GetRemainingTime())</span>
                    </div>
                    <div class="bpm">
                        <span>@cacheBpm</span>
                        <span>@cacheBpmAdjustment</span>
                    </div>
                </div>
                <span class="key">@((MarkupString)cacheKeyAdjustment)</span>
            </div>
            <div class="player-name" style="background-color: @Settings.Color">
                @Settings.Name
            </div>
        </div>
    }

    <div class="waveform-full">
        <Waveform CssColor="@Settings.Color"
                  Mode="Waveform.Modes.Full"
                  Player="this"
                  @ref="waveformFull" />
    </div>

    <div class="waveform @(Settings.ReverseControls ? "reverse" : "")">
        <Waveform CssColor="@Settings.Color"
                  Mode="Waveform.Modes.AudioSynced"
                  Player="this"
                  @ref="waveform" />

        <VuMeter @ref="vuMeter" />
        <div class="volume-monitor-container">
            <Fader Orientation="Fader.Orientations.Vertical" ValueChanged="ApplyTrackVolume" Name="<i class='fa-solid fa-volume-high'></i>" DefaultValue="0" @ref="faderVolume" />
            <div class="button-3d @(sendToMonitor ? "active" : "")" @onclick="ToggleSendToMonitor">
                <i class="fa-solid fa-headphones-simple"></i>
            </div>
        </div>

        @if(!MinimalMode) {
            <Fader Orientation="Fader.Orientations.Vertical" ValueChanged="ApplyTempo" Name="<i class='fa-solid fa-music'></i>" DefaultValue="0.5" @ref="faderTempo" />
            <Eq ValueChanged="ApplyEqValues" EqProfileChanged="EqProfileChanged" @ref="EqControls" />
            <Filters ValueChanged="ApplyFilterValues" @ref="FilterControls" />
        }
    </div>

    <div class="transport">
        <div class="button-3d icon led @(IsPlaying ? "green" : "")" @onmouseup="HandlePlayClick">
            <i class="fa-solid fa-play"></i>
        </div>
        <div class="button-3d icon" @onmouseup="HandleStopClick">
            <i class="fa-solid fa-stop"></i>
        </div>
        <div class="button-3d icon"
             @onmousedown="HandlePlayClick"
             @onmouseup="HandleStopAndSnapClick">
            <i class="fa-solid fa-forward-step"></i>
        </div>
        <div class="button-3d icon" @onmouseup="HandleSnapToClosestBeatMarker">
            <i class="fa-solid fa-down-left-and-up-right-to-center fa-rotate-by" style="--fa-rotate-angle: 45deg;"></i>
        </div>
        @if(!MinimalMode) {
            <div class="button-3d icon" @onmouseup="HandleRequestedFileCue"><i class="fa-solid fa-eject"></i></div>
            <div class="button-3d icon" @onmouseup="HandleSyncBPMToOtherPlayer"><i class='fa-solid fa-music'></i><i class="fa-solid fa-arrow-left small-arrow"></i><span>@(OtherPlayer?.Settings.Name ?? "")</span></div>
            <div class="button-3d icon" @onmouseup="HandleSyncKeyToOtherPlayer"><i class='fa-solid fa-key'></i><i class="fa-solid fa-arrow-left small-arrow"></i><span>@(OtherPlayer?.Settings.Name ?? "")</span></div>
            <div class="sync-adjust">
                <span>SYNC</span>
                <div class="sync-buttons">
                    <div class="button-3d" @onmousedown="SlowDown" @onmouseup="ResetTempo"><i class="fa-solid fa-left-long"></i></div>
                    <div class="button-3d" @onmousedown="SpeedUp" @onmouseup="ResetTempo"><i class="fa-solid fa-right-long"></i></div>
                </div>
            </div>
        }
    </div>

    @if(!MinimalMode) {
        <div class="ljc-container">
            <div class="loop-jump-cuepoints">
                <div class="loop-container @(selectedTab == 0 ? "" : "hidden")">
                    <div class="button-thin led @(Loop.Enabled ? "green" : "")" @onclick="ToggleLoop">Loop</div>
                    <div class="loop-size-container">
                        @foreach(var size in loopSizes) {
                            <div class="button @(loopSize == size.Item2 ? "selected" : "")"
                                 @onclick="() => SetLoopSize(size.Item2, false)">
                                @size.Item1
                            </div>
                        }
                    </div>
                    <div class="button-thin no-click">Jump</div>
                    <div class="loop-size-container">
                        @foreach(var size in loopSizes) {
                            <div class="button @(jumpSize == size.Item2 ? "selected" : "")"
                                 @onclick="() => SetJumpSize(size.Item2)">
                                @size.Item1
                            </div>
                        }

                        <div class="jump-buttons">
                            <div class="button-thin" @onclick="() => DoJump(-1)"><i class="fa-solid fa-caret-left"></i></div>
                            <div class="button-thin" @onclick="() => DoJump(+1)"><i class="fa-solid fa-caret-right"></i></div>
                        </div>
                    </div>
                    <div class="lock-button"><i class="fa-solid @(loopJumpLock ? "fa-lock" : "fa-lock-open")" @onclick="ToggleLoopJumpSync"></i></div>
                </div>

                <div class="scroller @(selectedTab == 1 ? "" : "hidden") @(File == null ? "disabled" : "")">
                    <CuePoints Player="this" />
                </div>
            </div>

            <div class="tabs">
                <button class="button-thin @(selectedTab == 0 ? "selected" : "")" @onclick="() => selectedTab = 0">Loop</button>
                <button class="button-thin @(selectedTab == 1 ? "selected" : "")" @onclick="() => selectedTab = 1">Cue</button>
            </div>
        </div>
    }
</div>

@code {
    private string lastFilename = "";
    private int selectedTab = 0;

    [JsonProperty] private int masterHandle = 0;
    [JsonProperty] private int streamHandle = 0;
    [JsonProperty] private int tempoHandle = 0;
    [JsonProperty] private int eqHandle = 0;
    [JsonProperty] private List<int> splitterStreams = [];
    [JsonProperty] private int masterSplitterHandle = 0;
    [JsonProperty] private int gainHandle = 0;
    [JsonProperty] private int pitchHandle = 0;

    [JsonProperty] private BASS_BFX_PEAKEQ eqParams = new();
    [JsonProperty] private BASS_BFX_VOLUME gain = new();
    [JsonProperty] private BASS_BFX_PITCHSHIFT pitch = new();
    private SYNCPROC loopSyncProc = null!;

    [JsonProperty] private double trackGain = 1.0;
    [JsonProperty] public double trackVolume = 1.0;
    [JsonProperty] public double monitorMix = 1.0;
    [JsonProperty] public double monitorVolume = 0.0;
    [JsonProperty] private double crossFaderVolume = 1.0;
    [JsonProperty] private bool isMono = false;
    [JsonProperty] private bool sendToMonitor = false;

    private Fader? faderVolume;
    private Fader? faderTempo;
    private Waveform? waveform;
    private Waveform? waveformFull;
    private VuMeter? vuMeter;
    [JsonProperty] public Eq EqControls = null!;
    [JsonProperty] public Filters FilterControls = null!;

    [JsonProperty] internal int WaveformWidth { get; set; } = 0;
    [JsonProperty] private long waveformStepLength = 0;
    [JsonProperty] private long trackLengthBytes = 0;
    private double playbackPosition = 0;
    private bool queueAutoSnap = false;
    [JsonProperty] internal double[] Peaks { get; set; } = [];
    [JsonProperty] internal double MaxPeak { get; set; } = 1.0;
    [JsonProperty] private double beatsPerSecond;
    [JsonProperty] private double secondsPerBeat;
    [JsonProperty] internal double SecondsToPosX { get; set; } = 0.0;
    [JsonProperty] private double currentTempoValue;
    private double tempoRange;
    private double tempoMin = +0.10;
    private double tempoMax = -0.10;

    private string cacheBpm = "";
    private string cacheBpmAdjustment = "";
    private string cacheKeyAdjustment = "";

    [JsonProperty] internal Loop Loop { get; set; } = new();
    private (string, double)[] loopSizes = {
        ("¼", 0.25),
        ("½", 0.50),
        ("1", 1.00),
        ("2", 2.00),
        ("4", 4.00),
        ("8", 8.00),
        ("16", 16.00),
        ("32", 32.00)
    };
    private double loopSize = 8.0;
    private double jumpSize = 8.0;
    private bool loopJumpLock = true;

    [JsonProperty] internal List<(double X, double Seconds)> BeatMarkers = new();
    [JsonProperty] private double cuePoint = 0;

    private KeyTools keyTools = new();

    public bool IsPlaying { get; set; }

    [Parameter]
    public DFile File { get; set; } = null!;

    [Parameter]
    public EventCallback RequestedFileCue { get; set; }

    [Parameter]
    public PlayerSettings Settings { get; set; } = null!;

    [Parameter, JsonIgnore]
    public Player? OtherPlayer { get; set; } = null;

    [Parameter]
    public bool MinimalMode { get; set; } = false;

    public long PlaybackHead {
        get => waveform?.PlaybackHead ?? 0;
    }

    [CascadingParameter]
    private MouseState? mouseState { get; set; } = null;

    public bool InBeat { get; set; } = false;

    public int InBeatIndex { get; set; } = 1;

    public int WaveformBarWidth { get; set; }

    private bool enableMouseEvents = true;
    public bool EnableMouseEvents {
        get => enableMouseEvents;
        set {
            if(faderVolume == null) return; // Session restore - ignore

            enableMouseEvents = value;
            if(!MinimalMode) {
                EqControls.EnableMouseEvents = value;
                if(faderTempo != null) faderTempo.EnableMouseEvents = value;
            }
            faderVolume!.EnableMouseEvents = value;
            waveform!.EnableMouseEvents = value;
            waveform!.IsMouseDown = false;
            waveformFull!.EnableMouseEvents = value;
            waveformFull!.IsMouseDown = false;
        }
    }

    public void SetTempoRange(double range) {
        tempoMin = range / 100.0;
        tempoMax = -range / 100.0;
        tempoRange = tempoMax - tempoMin;
    }

    private void HandlePlayClick(MouseEventArgs e) {
        if(e.Button == 0) Play(SnapToBeatMarkers && Program.Settings.Playback.SyncPlayback);
    }

    private void HandleStopClick(MouseEventArgs e) {
        if(e.Button == 0) Stop(false);
    }

    private void HandleStopAndSnapClick(MouseEventArgs e) {
        if(e.Button == 0) Stop(true);
    }

    private void HandleSnapToClosestBeatMarker(MouseEventArgs e) {
        if(e.Button == 0) SnapToClosestBeatMarker();
    }

    private void HandleRequestedFileCue(MouseEventArgs e) {
        if(e.Button == 0) RequestedFileCue.InvokeAsync();
    }

    private void HandleSyncBPMToOtherPlayer(MouseEventArgs e) {
        if(e.Button == 0) SyncBPMToOtherPlayer();
    }

    private void HandleSyncKeyToOtherPlayer(MouseEventArgs e) {
        if(e.Button == 0) SyncKeyToOtherPlayer();
    }

    public void Play(bool autoSync) {
        if(masterSplitterHandle == 0) return;
        if(IsPlaying) {
            splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelPause(h));
            IsPlaying = false;
        } else {
            if(autoSync && (OtherPlayer?.IsPlaying ?? false)) {
                Task.Run(async () => {
                    while(true) {
                        await Task.Delay(1);
                        if(OtherPlayer.InBeat && OtherPlayer.InBeatIndex == this.InBeatIndex) {
                            long p = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle);
                            long offset = Bass.BASS_ChannelSeconds2Bytes(streamHandle, secondsPerBeat / 10);

                            splitterStreams.ForEach(h => {
                                BassMix.BASS_Mixer_ChannelSetPosition(h, p + offset, BASSMode.BASS_POS_MIXER_RESET
                                                                                     | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                     | BASSMode.BASS_POS_FLUSH);
                                BassMix.BASS_Mixer_ChannelPlay(h);
                            });

                            IsPlaying = true;
                            break;
                        }
                    }
                });
            } else {
                splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelPlay(h));
                IsPlaying = true;
            }
        }

        SavePlayerState();
    }

    public void Stop(bool resetToCuePoint) {
        if(masterSplitterHandle == 0) return;

        splitterStreams.ForEach(h => {
            BassMix.BASS_Mixer_ChannelPause(h);
            BassMix.BASS_Mixer_ChannelSetPosition(h, Bass.BASS_ChannelSeconds2Bytes(h, resetToCuePoint ? cuePoint : 0), BASSMode.BASS_POS_MIXER_RESET
                                                                                                                        | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                                                        | BASSMode.BASS_POS_FLUSH);
        });
        IsPlaying = false;

        SavePlayerState();
    }

    public async Task SetTrackVolume(double value) {
        await faderVolume!.SetValue(value, true); // FIXME: Does this call ApplyTrackVolume?
    }

    public void SetMonitorVolume(double value) {
        monitorVolume = value;
        SetMatrixVolume();
    }

    public void SetMonitorMix(double value) {
        monitorMix = value;
        SetMatrixVolume();
    }

    public void SetCrossFaderVolume(double value) {
        crossFaderVolume = value;
        SetMatrixVolume();
    }

    private void ApplyTrackVolume(double value) {
        trackVolume = value;
        SetMatrixVolume();
    }

    public async Task SetTempo(double value) {
        await faderTempo!.SetValue(value, true);
    }

    private void ApplyTempo() {
        if(masterSplitterHandle == 0) return;
        double tempo = ReScaleTempoFader() * 100.0;

        bool r = Bass.BASS_ChannelSetAttribute(tempoHandle, BASSAttribute.BASS_ATTRIB_TEMPO, (float)tempo);
        if(Program.Settings.Playback.SyncPlayersBpm) {
            // FIXME: Implement necessary checks to avoid infinite recursion
            //OtherPlayer?.SyncBPMToOtherPlayer();
        }

        CacheBpmStrings();
    }

    public async void SyncBPMToOtherPlayer() {
        if(OtherPlayer?.File == null || File.BPM <= 0 || OtherPlayer.File.BPM <= 0) return;

        double otherPlayerBPM = OtherPlayer?.AdjustedBPM ?? 0;
        double factor = (1.0 - otherPlayerBPM / File.BPM) * 1.0 / Math.Abs(tempoRange);
        double faderValue = factor + 0.5;
        await faderTempo!.SetValue(faderValue, true);
    }

    private async void SyncKeyToOtherPlayer() {
        if(OtherPlayer?.File == null || File.Key == string.Empty || OtherPlayer.File.Key == string.Empty) return;

        var otherPlayerKey = keyTools.ToMidiNote(OtherPlayer.AdjustedKey);
        var thisPlayerKey = keyTools.ToMidiNote(File.Key);
        SetPitch(otherPlayerKey - thisPlayerKey);

        SetFiltersValues(-1, (otherPlayerKey - thisPlayerKey) / 12.0 + 0.5);
        await FilterControls.UpdateKnobs();
    }

    public double ReScaleTempoFader() {
        return ReScaleTempoValue((faderTempo?.Value ?? 0.5) - 0.5);
    }

    private double ReScaleTempoValue(double value, double oldMin = double.MinValue, double oldMax = double.MaxValue, double newMin = double.MinValue, double newMax = double.MaxValue) {
        if(oldMin == double.MinValue) oldMin = -0.5;
        if(oldMax == double.MaxValue) oldMax = +0.5;
        if(newMin == double.MinValue) newMin = tempoMin;
        if(newMax == double.MaxValue) newMax = tempoMax;
        return (((value - oldMin) * (newMax - newMin)) / (oldMax - oldMin)) + newMin;
    }

    private void CacheBpmStrings() {
        double bpm = (File?.BPM ?? 0) * (1.0 + ReScaleTempoFader());
        cacheBpm = bpm.ToString("N2");
        double adjustment = ReScaleTempoFader() * 100;
        cacheBpmAdjustment = $"{(adjustment > 0 ? "+" : "")}{adjustment:N2}%";
    }

    private void CacheKeyAdjustment() {
        if(File == null || File.Key == string.Empty) {
            cacheKeyAdjustment = "&nbsp;";
            return;
        }
        int semitones = (int)Math.Ceiling(pitch.fSemitones);
        string fromKey = keyTools.ConvertTo(File.Key, Program.Settings.KeyNotation);
        if(semitones == 0) {
            cacheKeyAdjustment = fromKey;
            return;
        }

        int keyNumber = keyTools.ToMidiNote(File.Key);
        string newKey = keyTools.FromMidiNote((int)(keyNumber + semitones), Program.Settings.KeyNotation);

        if(semitones > 0) {
            cacheKeyAdjustment = $"<span>{fromKey,3}</span><i class=\"fa-solid fa-arrow-right small-arrow\"></i><span>{newKey,3}</span>";
        } else {
            cacheKeyAdjustment = $"<span>{newKey,3}</span><i class=\"fa-solid fa-arrow-left small-arrow\"></i><span>{fromKey,3}</span>";
        }
    }

    private double AdjustedBPM {
        get => (File?.BPM ?? 0) * (1.0 + ReScaleTempoFader());
    }

    private string AdjustedKey {
        get {
            if(File == null || File.Key == string.Empty) return string.Empty;
            int semitones = (int)Math.Ceiling(pitch.fSemitones);
            if(semitones == 0) return File.Key;
            int keyNumber = keyTools.ToMidiNote(File.Key);
            return keyTools.FromMidiNote((int)(keyNumber + semitones), Program.Settings.KeyNotation);
        }
    }

    private void SlowDown(MouseEventArgs e) {
        if(e.Button == 0) {
            currentTempoValue = faderTempo!.Value;
            faderTempo?.SetValue(faderTempo.Value + 0.1, true);
        }
    }

    private void SpeedUp(MouseEventArgs e) {
        if(e.Button == 0) {
            currentTempoValue = faderTempo!.Value;
            faderTempo?.SetValue(faderTempo.Value - 0.1, true);
        }
    }

    private void ResetTempo(MouseEventArgs e) {
        if(e.Button == 0) faderTempo?.SetValue(currentTempoValue, true);
    }

    private void ApplyEqValues(Eq.EqValues eqValues) {
        // Low
        eqParams.lBand = 0;
        eqParams.fCenter = EqControls.EqProfile.Low;
        eqParams.fGain = (float)(eqValues.Low * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // Mid
        eqParams.lBand = 1;
        eqParams.fCenter = EqControls.EqProfile.Mid;
        eqParams.fGain = (float)(eqValues.Mid * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // Hi
        eqParams.lBand = 2;
        eqParams.fCenter = EqControls.EqProfile.Hi;
        eqParams.fGain = (float)(eqValues.Hi * 30 - 15);
        Bass.BASS_FXSetParameters(eqHandle, eqParams);
    }

    private void EqProfileChanged(EqualizerProfile eqProfile) {
        if(OtherPlayer != null) OtherPlayer.EqControls.EqProfile = eqProfile;
        UpdateSettings();
    }

    public void SetFiltersValues(double color = -1, double key = -1) {
        if(color != -1) FilterControls.FiltersValues.Color = color;
        if(key != -1) FilterControls.FiltersValues.Key = key;
    }

    private void ApplyFilterValues(Filters.FilterKeyValues filterValues) {
        SetPitch((filterValues.Key - 0.5) * 12);
        CacheKeyAdjustment();
    }

    private double GetRemainingTime() {
        if(File?.Duration > 0) return (File?.Duration - playbackPosition) ?? 0;
        return 0;
    }

    private void LoadFile() {
        IsPlaying = false;

        if(streamHandle != 0) {
            BassMix.BASS_Mixer_ChannelRemove(streamHandle);
            Bass.BASS_ChannelStop(streamHandle);
            Bass.BASS_StreamFree(streamHandle);
            streamHandle = 0;

            Bass.BASS_ChannelStop(masterHandle);
            Bass.BASS_StreamFree(masterHandle);
            masterHandle = 0;
        }

        if(File == null || faderVolume == null) return;

        var r = CreateStreams();
        if(r.Error != BASSError.BASS_OK) {
            // TODO: Do something so the user knows the file cannot be played
            Program.Logger.LogError($"Error creating stream ({r.Message}): {r.Error}");
        }

        trackGain = Math.Pow(10, (File.HasReplayGain ? File.ReplayGain : -2) / 20.0);
        ApplyTrackVolume(faderVolume!.Value);
        SetGain(gain.fVolume);
        SetupEQ();
        faderTempo?.SetValue(0.5);
        if(Loop.Enabled) ToggleLoop();

        trackLengthBytes = Bass.BASS_ChannelGetLength(streamHandle, BASSMode.BASS_POS_BYTE);
        waveformStepLength = Bass.BASS_ChannelSeconds2Bytes(streamHandle, Files.TimeSlice);

        Task.Run(async () => {
            while(!SetParameters()) await Task.Delay(1000);
            //queueAutoSnap = !IsPlaying; // FIXME: Uh???

            await InvokeAsync(StateHasChanged);
        });
    }

    private (BASSError Error, string Message) CreateStreams() {
        BASSError bassErrorCode = BASSError.BASS_OK;

        masterHandle = Bass.BASS_StreamCreateFile(File?.Filename, 0, 0, BASSFlag.BASS_STREAM_DECODE
                                                                        | BASSFlag.BASS_STREAM_PRESCAN
                                                                        | BASSFlag.BASS_ASYNCFILE
                                                                        | BASSFlag.BASS_SAMPLE_FLOAT);
        bassErrorCode = Bass.BASS_ErrorGetCode();
        if(masterHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(masterHandle));

        BASS_CHANNELINFO channelInfo = Bass.BASS_ChannelGetInfo(masterHandle);
        isMono = channelInfo.chans == 1;

        streamHandle = BassFx.BASS_FX_ReverseCreate(masterHandle, 30, BASSFlag.BASS_FX_FREESOURCE | BASSFlag.BASS_STREAM_DECODE);
        Bass.BASS_ChannelSetAttribute(streamHandle, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_FORWARD);
        if(streamHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(streamHandle));

        tempoHandle = BassFx.BASS_FX_TempoCreate(streamHandle, BASSFlag.BASS_FX_TEMPO_ALGO_SHANNON
                                                               | BASSFlag.BASS_STREAM_DECODE
                                                               | BASSFlag.BASS_FX_FREESOURCE);
        bassErrorCode = Bass.BASS_ErrorGetCode();
        if(tempoHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(tempoHandle));

        eqHandle = Bass.BASS_ChannelSetFX(streamHandle, BASSFXType.BASS_FX_BFX_PEAKEQ, 0);
        bassErrorCode = Bass.BASS_ErrorGetCode();
        if(eqHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(eqHandle));

        pitchHandle = Bass.BASS_ChannelSetFX(streamHandle, BASSFXType.BASS_FX_BFX_PITCHSHIFT, 0);
        bassErrorCode = Bass.BASS_ErrorGetCode();
        if(pitchHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(pitchHandle));
        pitch.fPitchShift = 0;
        pitch.fSemitones = 0;
        pitch.lOsamp = 32;

        if(!MinimalMode) {
            InitResonantFilter();
            int dspHandle = Bass.BASS_ChannelSetDSP(streamHandle, dspResonantFilter, IntPtr.Zero, 0);
            bassErrorCode = Bass.BASS_ErrorGetCode();
            if(dspHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(dspHandle));
        }

        splitterStreams.Clear();
        foreach(var mixHandle in Program.BassMixHandles) {
            int splitterHandle = BassMix.BASS_Split_StreamCreate(tempoHandle, BASSFlag.BASS_STREAM_DECODE, null);

            bassErrorCode = Bass.BASS_ErrorGetCode();
            if(splitterHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(splitterHandle));
            splitterStreams.Add(splitterHandle);

            bool r = BassMix.BASS_Mixer_StreamAddChannel(mixHandle.Handle, splitterHandle, BASSFlag.BASS_MIXER_CHAN_PAUSE
                                                                                           | BASSFlag.BASS_MIXER_CHAN_NORAMPIN
                                                                                           | BASSFlag.BASS_MIXER_CHAN_BUFFER
                                                                                           | BASSFlag.BASS_STREAM_AUTOFREE
                                                                                           | BASSFlag.BASS_MIXER_CHAN_MATRIX);
            bassErrorCode = Bass.BASS_ErrorGetCode();
            if(!r || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(BassMix.BASS_Mixer_StreamAddChannel));


            float[,] matrix = GetSpeakersMatrix(mixHandle.DeviceIndex);
            r = BassMix.BASS_Mixer_ChannelSetMatrix(splitterHandle, matrix);
            bassErrorCode = Bass.BASS_ErrorGetCode();
            if(!r || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(BassMix.BASS_Mixer_ChannelSetMatrix));
        }
        masterSplitterHandle = splitterStreams[0];

        gainHandle = Bass.BASS_ChannelSetFX(masterSplitterHandle, BASSFXType.BASS_FX_BFX_VOLUME, 0);
        bassErrorCode = Bass.BASS_ErrorGetCode();
        if(gainHandle == 0 || bassErrorCode != BASSError.BASS_OK) return (bassErrorCode, nameof(gainHandle));

        SetMatrixVolume();

        return (BASSError.BASS_OK, "");
    }

    public void SetPitch(double semiTones) {
        pitch.fSemitones = (float)semiTones;
        if(pitchHandle == 0) return;
        Bass.BASS_FXSetParameters(pitchHandle, pitch);
    }

    public void SetGain(float value) {
        gain.fVolume = value;
        if(gainHandle == 0) return;
        Bass.BASS_FXSetParameters(gainHandle, gain);
    }

    private float[,] GetSpeakersMatrix(int deviceIndex) {
        float[,] matrix;
        var audioDevices = Program.Settings.Audio.MainOutputDevice.Concat(Program.Settings.Audio.MonitorDevice).ToArray();
        var speakers = audioDevices[deviceIndex].Speakers;
        int index = Program.GetDeviceIndexByName(audioDevices[deviceIndex].Name);
        Bass.BASS_SetDevice(index);
        switch(Bass.BASS_GetInfo().speakers) {
            case 2:
                matrix = new float[,] {
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontRight) != 0) ? 1 : 0
                            }
    };
                break;

            case 4:
                matrix = new float[,] {
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontRight) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideRight) != 0) ? 1 : 0,
                            }
    };
                break;

            case 6:
                matrix = new float[,] {
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontRight) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.Center) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.LFE) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideRight) != 0) ? 1 : 0
                            }
    };
                break;

            case 8:
                matrix = new float[,] {
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.FrontRight) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.Center) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.LFE) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.SideRight) != 0) ? 1 : 0
                            },
                            {
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.RearLeft) != 0) ? 1 : 0,
                                0
                            },
                            {
                                0,
                                speakers.Any(c => (c & AudioDevice.DeviceSpeakers.RearRight) != 0) ? 1 : 0
                            }
    };
                break;

            default:
                matrix = new float[,] {
                            {
                                0,
                                0
                            }
    };
                break;
        }

        return matrix;
    }

    private void SetupEQ() {
        if(EqControls == null) return;
        // setup the EQ bands
        eqParams.fQ = 0f;
        eqParams.fBandwidth = 2.5f;
        eqParams.lChannel = BASSFXChan.BASS_BFX_CHANALL;

        // create 1st band for bass
        eqParams.lBand = 0;
        eqParams.fCenter = EqControls.EqProfile.Low;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // create 2nd band for mid
        eqParams.lBand = 1;
        eqParams.fCenter = EqControls.EqProfile.Mid;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        // create 3rd band for treble
        eqParams.lBand = 2;
        eqParams.fCenter = EqControls.EqProfile.Hi;
        Bass.BASS_FXSetParameters(eqHandle, eqParams);

        EqControls?.Reset();
    }

    public bool SetParameters() {
        Peaks = [];
        BeatMarkers.Clear();

        if(File == null || !File.WaveformUnZipped.Contains('|')) {
            waveformFull?.UpdateFullWaveform();
            return false;
        }

        Peaks = File.WaveformUnZipped.Split('|').Select(p => double.Parse(p)).ToArray();
        MaxPeak = Peaks.Max();

        WaveformWidth = Peaks.Length * WaveformBarWidth;
        beatsPerSecond = File!.BPM / 60.0;
        secondsPerBeat = 1.0 / beatsPerSecond;
        SecondsToPosX = 1.0 / (File.Duration == 0 ? 1 : File.Duration) * WaveformWidth;

        GenerateBeatMarkers();
        CacheBpmStrings();
        CacheKeyAdjustment();

        waveformFull?.UpdateFullWaveform();

        return true;
    }

    private void GenerateBeatMarkers() {
        if(File.DownbeatAt == -1) return;

        double t1 = File.DownbeatAt;
        double t2 = t1 - secondsPerBeat;
        while(t1 < File!.Duration || t2 >= 0) {
            if(t1 < File.Duration) {
                BeatMarkers.Add((t1 * SecondsToPosX, t1));
                t1 += secondsPerBeat;
            }
            if(t2 >= 0) {
                BeatMarkers.Insert(0, (t2 * SecondsToPosX, t2));
                t2 -= secondsPerBeat;
            }
        }
    }

    public void SnapToCuePoint(CuePoint cp) {
        if(File == null) return;
        long position = Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, cp.Position);
        cuePoint = cp.Position;
        splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, position, BASSMode.BASS_POS_MIXER_RESET
                                                                                        | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                        | BASSMode.BASS_POS_FLUSH));
    }

    public bool SnapToBeatMarkers => BeatMarkers.Count > 0 && (!mouseState?.ShiftDown ?? true);

    public void SnapToClosestBeatMarker() {
        if(BeatMarkers.Count == 0) return;
        long position = GetClosestBeatMarker();

        splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, position, BASSMode.BASS_POS_MIXER_RESET
                                                                                        | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                        | BASSMode.BASS_POS_FLUSH));
    }

    private long GetClosestBeatMarker() {
        double playbackPositionSeconds = Bass.BASS_ChannelBytes2Seconds(streamHandle, BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle));

        if(SnapToBeatMarkers) {
            int closestIndex = 0;
            double closestDistance = float.MaxValue;
            for(int i = 0; i < BeatMarkers.Count; i++) {
                double distance = Math.Abs(BeatMarkers[i].Seconds - playbackPositionSeconds);
                if(distance < closestDistance) {
                    closestDistance = distance;
                    closestIndex = i;
                }
            }
            playbackPositionSeconds = BeatMarkers[closestIndex].Seconds;
        }

        cuePoint = playbackPositionSeconds;
        return Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, cuePoint);
    }

    public void ToggleLoop() {
        if(File == null) return;
        Loop.Enabled = !Loop.Enabled;
        SetLoopSize(loopSize, true);
    }

    public void LoopSizeIncrease() {
        int index = Array.FindIndex(loopSizes, s => s.Item2 == loopSize);
        if(index != -1 && index < loopSizes.Length - 1) SetLoopSize(loopSizes[index + 1].Item2, false);
    }

    public void LoopSizeDecrease() {
        int index = Array.FindIndex(loopSizes, s => s.Item2 == loopSize);
        if(index != -1 && index > 0) SetLoopSize(loopSizes[index - 1].Item2, false);
    }

    public void JumpSizeIncrease() {
        int index = Array.FindIndex(loopSizes, s => s.Item2 == jumpSize);
        if(index != -1 && index < loopSizes.Length - 1) SetJumpSize(loopSizes[index + 1].Item2);
    }

    public void JumpSizeDecrease() {
        int index = Array.FindIndex(loopSizes, s => s.Item2 == jumpSize);
        if(index != -1 && index > 0) SetJumpSize(loopSizes[index - 1].Item2);
    }

    public void JogWheelForward() {
        if(File == null) return;
        long p = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle);
        long offset = p + Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, 0.05 / beatsPerSecond);
        if(offset > trackLengthBytes) return;
        if(offset < 0) offset = 0;
        splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, offset, BASSMode.BASS_POS_MIXER_RESET
                                                                                      | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                      | BASSMode.BASS_POS_FLUSH));
    }

    public void JogWheelBackward() {
        if(File == null) return;
        long p = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle);
        long offset = p - Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, 0.05 / beatsPerSecond);
        if(offset > trackLengthBytes) return;
        if(offset < 0) offset = 0;
        splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, offset, BASSMode.BASS_POS_MIXER_RESET
                                                                                      | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                      | BASSMode.BASS_POS_FLUSH));
    }

    private void SetLoopSize(double size, bool resetStart) {
        loopSize = size;
        if(loopJumpLock) jumpSize = loopSize;

        if(File == null) return;

        double position = Bass.BASS_ChannelBytes2Seconds(masterSplitterHandle, GetClosestBeatMarker());
        if(resetStart) Loop.Start = position;
        Loop.End = Loop.Start + loopSize / beatsPerSecond;

        if(Loop.BASSHandle != 0 && resetStart) {
            Bass.BASS_ChannelRemoveSync(masterSplitterHandle, Loop.BASSHandle);
            Loop.BASSHandle = 0;
        }

        if(Loop.Enabled) {
            bool resetLoop = position <= Loop.End && loopSize > 1;
            Loop.StartBytes = Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, Loop.Start);
            Loop.EndBytes = Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, Loop.End);

            if(Loop.EndBytes > trackLengthBytes) {
                Loop.Enabled = false;
                return;
            }

            if(resetStart || resetLoop) {
                Loop.Reset = false;

                Bass.BASS_ChannelLock(masterSplitterHandle, true);
                if(Loop.BASSHandle != 0) {
                    Bass.BASS_ChannelRemoveSync(masterSplitterHandle, Loop.BASSHandle);
                    Loop.BASSHandle = 0;
                }
                Loop.BASSHandle = Bass.BASS_ChannelSetSync(masterSplitterHandle, BASSSync.BASS_SYNC_POS | BASSSync.BASS_SYNC_MIXTIME, Loop.EndBytes, loopSyncProc, IntPtr.Zero);
                Bass.BASS_ChannelLock(masterSplitterHandle, false);
            } else {
                Loop.Reset = true;
            }
        }

        UpdateSettings();
    }

    private void SetJumpSize(double size) {
        if(loopJumpLock) {
            SetLoopSize(size, false);
        } else {
            jumpSize = size;
        }
        UpdateSettings();
    }

    public void ToggleLoopJumpSync() {
        loopJumpLock = !loopJumpLock;
        if(loopJumpLock) jumpSize = loopSize;
        UpdateSettings();
    }

    private void UpdateSettings() {
        Settings.LoopJumpLock = loopJumpLock;
        Settings.LoopSize = loopSize;
        Settings.JumpSize = jumpSize;
        Program.Settings.Playback.EqProfile = EqControls.EqProfile.Name;
    }

    private void DoLoop(int handle, int channel, int data, IntPtr user) {
        if(Loop.Enabled) {
            splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, Loop.StartBytes, BASSMode.BASS_POS_MIXER_RESET
                                                                                                   | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                                   | BASSMode.BASS_POS_FLUSH));

            if(Loop.Reset) {
                Loop.Reset = false;

                Bass.BASS_ChannelLock(masterSplitterHandle, true);
                Bass.BASS_ChannelRemoveSync(masterSplitterHandle, Loop.BASSHandle);
                Loop.BASSHandle = Bass.BASS_ChannelSetSync(masterSplitterHandle, BASSSync.BASS_SYNC_POS | BASSSync.BASS_SYNC_MIXTIME, Loop.EndBytes, loopSyncProc, IntPtr.Zero);
                Bass.BASS_ChannelLock(masterSplitterHandle, false);
            }
        }
    }

    private void DoJump(int direction) {
        Task.Run(async () => {
            while(true) {
                await Task.Delay(1);
                if(InBeat) {
                    long p = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle);
                    long offset = p + direction * Bass.BASS_ChannelSeconds2Bytes(masterSplitterHandle, direction * (secondsPerBeat / 10) + jumpSize / beatsPerSecond);
                    if(offset > trackLengthBytes) return;
                    if(offset < 0) offset = 0;

                    splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, offset, BASSMode.BASS_POS_MIXER_RESET
                                                                                                  | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                                  | BASSMode.BASS_POS_FLUSH));
                    break;
                }
            }
        });
    }

    private void ToggleSendToMonitor(MouseEventArgs e) {
        if(e.Button == 0) {
            sendToMonitor = !sendToMonitor;
            SetMatrixVolume();
        }
    }

    private void SetMatrixVolume() {
        if(File == null) return;

        int mainOutputDevicesCount = Program.Settings.Audio.MainOutputDevice.Count;

        // Main output devices
        for(int mainDeviceIndex = 0; mainDeviceIndex < mainOutputDevicesCount; mainDeviceIndex++) {
            var speakersMatrix = GetSpeakersMatrix(mainDeviceIndex);
            for(int i = 0; i < speakersMatrix.GetLength(0); i++) {
                for(int j = 0; j < speakersMatrix.GetLength(1); j++) {
                    speakersMatrix[i, j] *= (float)(trackVolume * crossFaderVolume);
                }
            }
            var splitterStream = splitterStreams[mainDeviceIndex];
            BassMix.BASS_Mixer_ChannelSetMatrix(splitterStream, speakersMatrix);
        }

        // Monitor devices
        for(int monitorDeviceIndex = 0; monitorDeviceIndex < Program.Settings.Audio.MonitorDevice.Count; monitorDeviceIndex++) {
            var speakersMatrix = GetSpeakersMatrix(mainOutputDevicesCount + monitorDeviceIndex);
            for(int i = 0; i < speakersMatrix.GetLength(0); i++) {
                for(int j = 0; j < speakersMatrix.GetLength(1); j++) {
                    speakersMatrix[i, j] *= (float)(sendToMonitor ? (trackVolume * monitorMix) : (1.0 - monitorMix) * trackVolume * crossFaderVolume * monitorVolume);
                }
            }
            var splitterStream = splitterStreams[mainOutputDevicesCount + monitorDeviceIndex];
            BassMix.BASS_Mixer_ChannelSetMatrix(splitterStream, speakersMatrix);
        }
    }

    private DSPPROC dspResonantFilter = null!;
    private void InitResonantFilter() {
        // Cascaded resonant lp/hp filter
        // https://www.musicdsp.org/en/latest/Filters/131-cascaded-resonant-lp-hp-filter.html
        // http://192.168.1.8:88/Filters/131-cascaded-resonant-lp-hp-filter.html (RPi4 (/home/xfx/musicdsp/build/html): sudo python -m http.server 88)
        // https://github.com/bdejong/musicdsp

        int step = isMono ? 1 : 2;
        const float lowPassMaxFreq = 0.95f;
        const float hiPassMinFreq = 0.03f;

        dspResonantFilter = new((int handle, int channel, IntPtr buffer, int length, IntPtr user) => {
            int len = length / (2 * step);
            float[] input = new float[len];
            float[] result = new float[len];
            Marshal.Copy(buffer, input, 0, len);

            float n1_l = 0, n2_l = 0, n3_l = 0, n4_l = 0;
            float n1_r = 0, n2_r = 0, n3_r = 0, n4_r = 0;

            float res = (float)FilterControls.FiltersValues.Color;
            if(res == 0.5f) return;
            if(res >= lowPassMaxFreq) res = lowPassMaxFreq;
            if(res <= hiPassMinFreq) res = hiPassMinFreq;

            float cut_lp = res < 0.5f ? Math.Max(hiPassMinFreq, lowPassMaxFreq - 2.0f * (0.5f - res)) : lowPassMaxFreq; // cutoff frequency of the lowpass [0..1)
            float cut_hp = res > 0.5 ? Math.Min(2.0f * (res - 0.5f), lowPassMaxFreq) : hiPassMinFreq; // cutoff frequency of the hipass [0..1)
            float res_lp = res < 0.5f ? 2.0f * (0.5f - res) : 0.0f; // resonance of the lowpass (0..1)
            float res_hp = res > 0.5f ? 2.0f * (res - 0.5f) : 0.0f; // resonance of the hipass (0..1)

            float fb_lp = res_lp + res_lp / (1.0f - cut_lp);
            float fb_hp = res_hp + res_hp / (1.0f - cut_hp);

            for(int i = 0; i < len; i += step) {
                n1_l += cut_lp * (input[i] - n1_l + fb_lp * (n1_l - n2_l));
                n2_l += cut_lp * (n1_l - n2_l);
                n3_l += cut_hp * (input[i] - n3_l + fb_hp * (n3_l - n4_l));
                n4_l += cut_hp * (n3_l - n4_l);
                result[i] = n2_l - n4_l;

                if(isMono) continue;
                n1_r += cut_lp * (input[i + 1] - n1_r + fb_lp * (n1_r - n2_r));
                n2_r += cut_lp * (n1_r - n2_r);
                n3_r += cut_hp * (input[i + 1] - n3_r + fb_hp * (n3_r - n4_r));
                n4_r += cut_hp * (n3_r - n4_r);
                result[i + 1] = n2_r - n4_r;
            }

            Marshal.Copy(result, 0, buffer, len);
        });
    }

    // TODO: This is a very taxing operation, so it might be a good idea to allow the user to disable it
    // Disabling it would disable the playback sync and the beat monitor
    // TODO: Can we use the BASS channel syncs to do this more efficiently? !IMPORTANT
    private async Task MonitorBeats() {
        double threshold = 0.01;
        int interval = 0;
        while(true) {
            await Task.Delay(1);

            if(Bass.BASS_ChannelIsActive(masterSplitterHandle) == BASSActive.BASS_ACTIVE_PLAYING) {
                playbackPosition = Bass.BASS_ChannelBytes2Seconds(masterSplitterHandle, BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle));

                InBeat = false;
                for(int i = 0; i < BeatMarkers.Count; i++) {
                    if(Math.Abs(BeatMarkers[i].Seconds - playbackPosition) < threshold) {
                        InBeatIndex = i % 2 + 1;
                        InBeat = true;
                        break;
                    }
                }

                if(++interval > 30) {
                    if(IsPlaying) {
                        float[] levelsReal = BassMix.BASS_Mixer_ChannelGetLevel(handle: masterSplitterHandle, flags: BASSLevel.BASS_LEVEL_MONO);
                        vuMeter?.SetLevel(levelsReal[0], levelsReal[0] * trackVolume * crossFaderVolume, InBeatIndex);
                    } else {
                        vuMeter?.SetLevel(0, 0, InBeatIndex);
                    }

                    interval = 0;
                }
            }
        }
    }

    private async Task MonitorPlayback() {
        int intervals = 0;
        int delay = 30;
        long lastPos = 0;
        bool isPlayingBackwards = false;
        bool isPaused = false;

        while(true) {
            await Task.Delay(delay * ((waveform?.IsMouseDown ?? true) ? 2 : 1));

            if(Bass.BASS_ChannelIsActive(masterSplitterHandle) == BASSActive.BASS_ACTIVE_PLAYING) {
                if(isPaused && IsPlaying) {
                    splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelPlay(h));
                    isPaused = false;
                }

                if(waveform!.IsMouseDown) {
                    long pos = waveform.PlaybackHead * waveformStepLength / WaveformBarWidth;
                    long playerPos = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle);

                    if(pos == lastPos) {
                        //splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelPause(h));
                        //isPaused = true;
                    } else {
                        // TODO: Calculate scrubbing speed based on how far the mouse is from the current playback position
                        // and adjust the channel pitch accordingly

                        // Naive scrubbing implementation
                        splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, pos, BASSMode.BASS_POS_MIXER_RESET
                                                                                                   | BASSMode.BASS_MIXER_CHAN_NORAMPIN));

                        if(pos > lastPos) {
                            Bass.BASS_ChannelSetAttribute(streamHandle, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_FORWARD);
                            isPlayingBackwards = false;
                        } else if(pos < lastPos) {
                            Bass.BASS_ChannelSetAttribute(streamHandle, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_REVERSE);
                            isPlayingBackwards = true;
                        }
                        lastPos = pos;
                    }

                } else if(waveformFull!.IsMouseDown) {
                    long pos = waveformFull.PlaybackHead * waveformStepLength / WaveformBarWidth;
                    splitterStreams.ForEach(h => BassMix.BASS_Mixer_ChannelSetPosition(h, pos, BASSMode.BASS_POS_MIXER_RESET
                                                                                               | BASSMode.BASS_MIXER_CHAN_NORAMPIN
                                                                                               | BASSMode.BASS_POS_FLUSH));
                } else {
                    waveform.PlaybackHead = BassMix.BASS_Mixer_ChannelGetPosition(masterSplitterHandle) * WaveformBarWidth / waveformStepLength;
                    waveformFull.PlaybackHead = waveform.PlaybackHead;

                    if(isPlayingBackwards) {
                        Bass.BASS_ChannelSetAttribute(streamHandle, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_FORWARD);
                    }
                }

                await waveform.Refresh();
                if(intervals % 10 == 0) await waveformFull!.Refresh();
            } else if(IsPlaying) {
                Stop(false);
                CreateStreams();
                Bass.BASS_ChannelSetPosition(streamHandle, trackLengthBytes - 1);
            }

            if(++intervals % 24 == 0) await InvokeAsync(StateHasChanged);
        }
    }

    int dragCounter = 0;
    private void HandleDragEnter(DragEventArgs e) {
        mouseState!.Enabled = false;
        dragCounter += 1;
    }

    private void HandleDragLeave(DragEventArgs e) {
        dragCounter -= 1;
        if(dragCounter <= 0) {
            mouseState!.Enabled = true;
            dragCounter = 0;
        }
    }

    private async Task HandleDrop(DragEventArgs e) {
        mouseState!.Enabled = true;
        mouseState!.ButtonsDown = 0;
        mouseState!.IsCaptured = false;

        await RequestedFileCue.InvokeAsync();
    }

    private void HandleDragOver(DragEventArgs e) {
        // Do nothing
        // This is just a placeholder to avoid the deprecation warning about using inline JavaScript: ondragover="event.preventDefault()"
    }

    private void SavePlayerState() {
        try {
            session.Set($"Player-{Settings.Name}", JsonConvert.SerializeObject(this));
        } catch(Exception ex) {
            Program.Logger.LogError($"Error saving player state: {ex.Message}");
        }
    }

    private void RestorePlayerState() {
        string? playerJson = session.Get<string>($"Player-{Settings.Name}");
        if(playerJson != null) {
            Player? p = JsonConvert.DeserializeObject<Player>(playerJson);
            if(p != null) {
                masterHandle = p.masterHandle;
                streamHandle = p.streamHandle;
                tempoHandle = p.tempoHandle;
                eqHandle = p.eqHandle;
                splitterStreams = p.splitterStreams;
                masterSplitterHandle = p.masterSplitterHandle;
                gainHandle = p.gainHandle;

                eqParams = p.eqParams;
                gain = p.gain;
                trackGain = p.trackGain;

                if(p.File != null) {
                    lastFilename = "";
                    File = p.File;
                }

                EqControls = p.EqControls;
                FilterControls = p.FilterControls;

                crossFaderVolume = p.crossFaderVolume;
                Loop = p.Loop;
                WaveformWidth = p.WaveformWidth;
                trackLengthBytes = p.trackLengthBytes;
                waveformStepLength = p.waveformStepLength;
                Peaks = p.Peaks;
                MaxPeak = p.MaxPeak;
                beatsPerSecond = p.beatsPerSecond;
                secondsPerBeat = p.secondsPerBeat;
                SecondsToPosX = p.SecondsToPosX;
                BeatMarkers = p.BeatMarkers;
                cuePoint = p.cuePoint;
                IsPlaying = p.IsPlaying;
                isMono = p.isMono;
            }
        }
    }

    protected override void OnInitialized() {
        base.OnInitialized();

        loopSyncProc = new SYNCPROC(DoLoop);

        SetTempoRange(Program.Settings.Playback.TempoRange);

        Task.Run(MonitorPlayback);
        Task.Run(MonitorBeats);
    }

    protected override void OnParametersSet() {
        if(File != null) {
            if(lastFilename == File.Filename) {
                SetParameters();
            } else {
                if(IsPlaying && Program.Settings.Playback.LockOnPlay) return;

                lastFilename = File.Filename;
                Stop(false);
                LoadFile();

                SavePlayerState();
            }
        }

        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender && faderVolume != null && (faderTempo != null || MinimalMode)) {
            faderVolume!.SetInitialValue(0.8);
            WaveformBarWidth = Program.Settings.Playback.WaveformZoom;
            if(!MinimalMode) {
                faderTempo?.SetInitialValue(0.5);
                EqControls.EqProfile = Program.Settings.EqualizerProfiles.FirstOrDefault(p => p.Name == Program.Settings.Playback.EqProfile) ?? Program.Settings.EqualizerProfiles[0];

                loopJumpLock = Settings.LoopJumpLock;
                loopSize = Settings.LoopSize;
                jumpSize = Settings.JumpSize;
            }

            RestorePlayerState();

            await InvokeAsync(StateHasChanged);
        }

        if(queueAutoSnap) {
            SnapToClosestBeatMarker();
            queueAutoSnap = false;
        }
    }
}