@using System.Threading.Tasks
@inject IJSRuntime JS

<div class="dialog-background @(IsOpen ? "show" : "")">
    <div class="dialog-container @(IsOpen ? "show" : "")" @ref="dialogElement">
        <div class="title" @ref="topBarElement">
            <span>@Title</span>
            <div class="close" @onclick="Close"><i class="fa-solid fa-close"></i></div>
        </div>

        <div class="scroller">
            <div class="properties-container">
                @ChildContent
            </div>
        </div>

        <div class="buttons-container">
            @foreach(var button in Buttons) {
                <div class="dlg-button @button.Class" @onclick="button.Click"><i class="@button.Icon"></i> @button.Text</div>
            }
        </div>
    </div>
</div>

@code {
    public class Button {
        public string Text { get; set; } = "";
        public string Icon { get; set; } = "";
        public string Class { get; set; } = "";
        public EventCallback Click { get; set; }
    }

    [Parameter]
    public string Title { get; set; } = "";

    [Parameter]
    public bool Movable { get; set; } = false; // FIXME: This breaks mouse support on all the controls inside the dialog

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;

    [Parameter]
    public EventCallback OnOpen { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback OnSave { get; set; }

    [Parameter]
    public Button[] Buttons { get; set; } = Array.Empty<Button>();

    public bool IsOpen { get; set; } = false;

    private Bounds? dialogBounds = default!;
    private ElementReference dialogElement;

    private Bounds? topBarBounds = default!;
    private ElementReference topBarElement;
    // private double lastMousePosX = -1;
    // private double lastMousePosY = -1;
    // private double dx = 0;
    // private double dy = 0;

    [CascadingParameter]
    private MouseState mouseState { get; set; } = default!;

    public void Open() {
        if(!IsOpen) {
            IsOpen = true;
            OnOpen.InvokeAsync();
            InvokeAsync(StateHasChanged);
        }
    }

    public void Close() {
        if(IsOpen) {
            IsOpen = false;
            OnClose.InvokeAsync();
        }
    }

    public void Save() {
        OnSave.InvokeAsync();
        Close();
    }

    [JSInvokable]
    public async Task OnResize() {
        dialogBounds = new Bounds(await JS.InvokeAsync<double[]>("getElementBounds", dialogElement));
        topBarBounds = new Bounds(await JS.InvokeAsync<double[]>("getElementBounds", topBarElement));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        return; // Disable movable dialogs for now
        // if(!Movable) return;

        // if(firstRender) {
        //     var dotNetReference = DotNetObjectReference.Create(this);
        //     await JS.InvokeVoidAsync("Diyokee.monitorResize", dotNetReference);

        //     await Task.Run(async () => {
        //         bool isValid = false;
        //         int delay = 60;
        //         while(true) {
        //             await Task.Delay(delay);
        //             if(!IsOpen) continue;

        //             if(dialogBounds == null || dialogBounds?.Width == 0 || dialogBounds?.Height == 0) {
        //                 await OnResize();
        //             }

        //             if(!isValid
        //                 && dialogBounds != null
        //                 && topBarBounds != null
        //                 && (!mouseState?.IsCaptured ?? false)
        //                 && mouseState?.ButtonsDown == 1
        //                 && topBarBounds.Contains(mouseState.X, mouseState.Y)) {

        //                 mouseState.IsCaptured = true;
        //                 isValid = true;
        //             }

        //             if(isValid) {
        //                 if(mouseState!.ButtonsDown == 1) {
        //                     if(lastMousePosX == -1) {
        //                         lastMousePosX = mouseState.X;
        //                         lastMousePosY = mouseState.Y;
        //                         continue;
        //                     }

        //                     dx += mouseState.X - lastMousePosX;
        //                     dy += mouseState.Y - lastMousePosY;

        //                     await JS.InvokeVoidAsync("setElementBounds", dialogElement, new string[] {
        //                         $"calc(50% + {dx}px)", $"calc(50% + {dy}px)", "-1", "-1", ""
        //                     });

        //                     lastMousePosX = mouseState.X;
        //                     lastMousePosY = mouseState.Y;
        //                 } else {
        //                     mouseState!.IsCaptured = false;
        //                     isValid = false;

        //                     lastMousePosX = -1;
        //                     lastMousePosY = -1;
        //                 }
        //             }
        //         }
        //     });
        // }
    }

    protected override void OnInitialized() {
        if(Buttons.Length == 0) {
            Buttons = new Button[] {
                new Button { Text = "Save", Class = "primary", Click = EventCallback.Factory.Create(this, Save) },
                new Button { Text = "Cancel", Class = "secondary", Click = EventCallback.Factory.Create(this, Close) }
            };
        }
    }
}
