@using System.Threading.Tasks
@inject IJSRuntime JS

<div class="dialog-background @(IsOpen ? "show" : "")">
    <div class="dialog-container @(IsOpen ? "show" : "")" @ref="dialogElement">
        <MouseSupport SupportMouseWheel="false" OnMouseEvent="@HandleMouseEvent">
            <div class="title">
                <span>@Title</span>
                <div class="close" @onclick="Close"><i class="fa-solid fa-close"></i></div>
            </div>
        </MouseSupport>

        <div class="scroller">
            <div class="properties-container">
                @ChildContent
            </div>
        </div>

        <div class="buttons-container">
            @foreach(var button in Buttons) {
                <div class="dlg-button @button.Class" @onclick="button.Click"><i class="@button.Icon"></i> @button.Text</div>
            }
        </div>
    </div>
</div>

@code {
    public class Button {
        public string Text { get; set; } = "";
        public string Icon { get; set; } = "";
        public string Class { get; set; } = "";
        public EventCallback Click { get; set; }
    }

    [Parameter]
    public string Title { get; set; } = "";

    [Parameter]
    public bool Movable { get; set; } = false; // FIXME: This breaks mouse support on all the controls inside the dialog

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;

    [Parameter]
    public EventCallback OnOpen { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback OnSave { get; set; }

    [Parameter]
    public Button[] Buttons { get; set; } = Array.Empty<Button>();

    public bool IsOpen { get; set; } = false;

    private ElementReference dialogElement;

    [CascadingParameter]
    private MouseState mouseState { get; set; } = default!;
    private MouseState lastMouseState { get; set; } = new();

    private double dx;
    private double dy;
    private async Task HandleMouseEvent() {
        if(!Movable) return;
        if(lastMouseState.ButtonsDown != mouseState.ButtonsDown) {
            lastMouseState.X = mouseState.X;
            lastMouseState.Y = mouseState.Y;
            lastMouseState.ButtonsDown = mouseState.ButtonsDown;
        }

        dx += mouseState.X - lastMouseState.X;
        dy += mouseState.Y - lastMouseState.Y;

        await JS.InvokeVoidAsync("setElementBounds", dialogElement, new string[] {
            $"calc(50% + {dx}px)", $"calc(50% + {dy}px)", "-1", "-1", ""
        });

        lastMouseState.X = mouseState.X;
        lastMouseState.Y = mouseState.Y;
    }

    public void Open() {
        if(!IsOpen) {
            IsOpen = true;
            OnOpen.InvokeAsync();
        }
    }

    public void Close() {
        if(IsOpen) {
            IsOpen = false;
            OnClose.InvokeAsync();
        }
    }

    public void Save() {
        OnSave.InvokeAsync();
        Close();
    }

    protected override void OnInitialized() {
        if(Buttons.Length == 0) {
            Buttons = new Button[] {
                new Button { Text = "Save", Class = "primary", Click = EventCallback.Factory.Create(this, Save) },
                new Button { Text = "Cancel", Class = "secondary", Click = EventCallback.Factory.Create(this, Close) }
            };
        }
    }
}
