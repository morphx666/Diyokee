@using System.Diagnostics
@using Diyokee
@using Diyokee.MediaProviders
@using Newtonsoft.Json
@using Un4seen.Bass
@using Un4seen.Bass.AddOn.Mix
@using Un4seen.Bass.AddOn.Midi
@using static Diyokee.Settings
@inject IJSRuntime JS
@inject SessionState session

@page "/"

<PageTitle>Diyokee</PageTitle>

<div class="main-console"
     tabindex="0"
     @onkeydown="HandleKeyDown"
     @onkeydown:preventDefault="false"
     @onkeyup="HandleKeyUp"
     @onkeyup:preventDefault="false"
     @onmousedown="HandleMouseDown"
     @onmousemove="HandleMouseMove"
     @onmouseup="HandleMouseUp"
     @onmousewheel="HandleMouseWheel"
     @onwheel="HandleMouseWheel">
    <CascadingValue Value="@mouseState">
        <div class="players" @ref="playersPanel">
            <div class="player">
                <Player
                    Settings="Program.Settings.Playback.Players[0]"
                    File="@player1File"
                    RequestedFileCue="() => LoadSelectedFile(player1)"
                    OtherPlayer="@player2"
                    @ref="player1" />
            </div>

            <div class="global-controls">
                <Knob Name="GAIN" @ref="mainGain" ValueChanged="ApplyMainGain" />
                <div class="button-thin" @onclick="OpenSettingsDialog"><i class="fa-solid fa-gear"></i></div>
            </div>

            <div class="player">
                <Player
                    Settings="Program.Settings.Playback.Players[1]"
                    File="@player2File"
                    RequestedFileCue="() => LoadSelectedFile(player2)"
                    OtherPlayer="@player1"
                    @ref="player2" />
            </div>
        </div>

        <div class="mixer" @ref="mixerPanel">
            <div class="crossfade-controls">
                <div class="button-3d" @onclick="() => HandleAutoCrossFade(-1)"><i class="fa-solid fa-caret-left"></i></div>
                <Fader Orientation="Fader.Orientations.Horizontal" ValueChanged="ApplyCrossfaderVolume" DefaultValue="0.5" @ref="crossFader" />
                <div class="button-3d" @onclick="() => HandleAutoCrossFade(+1)"><i class="fa-solid fa-caret-right"></i></div>
            </div>
            <div class="monitor-controls">
                <i class="fa-solid fa-volume-high"></i>
                <Knob Name="Mix" @ref="monitorMix" ValueChanged="ApplyMonitorMix" Enabled="false" />
                <i class="fa-solid fa-headphones-simple"></i>
            </div>
        </div>

        <PanelResize Orientation="PanelResize.Orientations.Vertical"
                     ResizeElement="playersPanel"
                     ElementsBetween="new() { mixerPanel }"
                     Name="main-resize-vertical"
                     OnResizeEnd="HandleDividerResize"
                     Constrains="playersConstrains" />

        <div class="media">
            <div class="media-providers" @ref="mediaProviderPanel">
                <div class="tabs">
                    @foreach(IMediaProvider provider in mediaProviders) {
                        <div class="tab @(selectedMediaProvider == provider ? "selected" : "")"
                            @onclick="() => {
                                selectedMediaProvider = provider;
                                // FIXME: Hopefully we can find an easier way to do this...
                                selectedMediaProvider.InitialPath = Program.Settings.MediaProviders.Where(mp => mp.Name == provider.Name).First().InitialPath;
                                SelectedFolderChanged(provider.RootPath);
                                shouldRender = true;
                            }">
                            @provider.Name
                        </div>
                    }
                </div>

                <div class="sources panel">
                    <MediaProviderContainer
                        Provider="@selectedMediaProvider"
                        SelectedFolderChanged="SelectedFolderChanged"
                        @ref="mediaProviderContainerUI"
                    />
                </div>
            </div>

            <PanelResize Orientation="PanelResize.Orientations.Horizontal"
                         ResizeElement="mediaProviderPanel"
                         Name="main-resize-horizontal"
                         OnResizeEnd="HandleDividerResize"
                         Constrains="mediaProviderConstrains" />

            <Files
                Provider="@selectedMediaProvider"
                RelativePath="@selectedFolder"
                SelectedFileChanged="SelectedFileChanged"
                TrackSettingsDialogOpen="() => SetPlayersMouseCapturing(false)"
                TrackSettingsDialogClosed="() => SetPlayersMouseCapturing(true)"
                @ref="filesComponent" />
        </div>

        <Settings
            OnSave="UpdateApp"
            OnClose="() => {
                        SetPlayersMouseCapturing(true);
                        enableMidiEvents = true;
                    }"
            @ref="settingsComponent" />
    </CascadingValue>
</div>

@code {
    private List<IMediaProvider> mediaProviders = new();
    private IMediaProvider? selectedMediaProvider;
    private string selectedFolder = "";

    private DFile? selectedFile = null;
    private DFile? player1File = null;
    private DFile? player2File = null;

    private Files? filesComponent;
    private MediaProviderContainer? mediaProviderContainerUI;

    private Player? player1;
    private Player? player2;

    private Components.Settings settingsComponent = null!;

    private Fader? crossFader;

    private MouseState mouseState = new();

    private ElementReference playersPanel;
    private ElementReference mixerPanel;
    private Dictionary<PanelResize.ConstrainKeys, string> playersConstrains = new() { { PanelResize.ConstrainKeys.Min, "420" } };
    private ElementReference mediaProviderPanel;
    private Dictionary<PanelResize.ConstrainKeys, string> mediaProviderConstrains = new() { { PanelResize.ConstrainKeys.Min, "250" } };

    private Knob? monitorMix = null!;
    private Knob? mainGain = null!;

    private bool shouldRender = true;
    private bool enableMidiEvents = true;

    public MainConsole() {
        SetMediaProviders();
    }

    private void LoadSelectedFile(Player? player) {
        if(player!.IsPlaying && Program.Settings.Playback.LockOnPlay) return;

        if(player == player1) {
            player1File = selectedFile;
        } else if(player == player2) {
            player2File = selectedFile;
        }
        shouldRender = true;
    }

    private void SelectedFolderChanged(string folder) {
        if(selectedMediaProvider == null) return;

        Program.Settings.MediaProviders.ForEach(mp => {
            if(mp.Name == selectedMediaProvider.Name) {
                mp.InitialPath = selectedMediaProvider.RootPath == folder ? "" : folder;
            }
        });
        selectedFolder = folder;
        shouldRender = true;

        session.Set(nameof(selectedFolder), folder);
    }

    private void SelectedFileChanged(DFile file) {
        selectedFile = file;
        shouldRender = true;

        if(player1!.File?.Filename == file.Filename) player1File = selectedFile;
        if(player2!.File?.Filename == file.Filename) player2File = selectedFile;

        session.Set(nameof(selectedFile), file);
    }

    private void HandleKeyDown(KeyboardEventArgs e) {
        mouseState.ShiftDown = e.ShiftKey;
        if(e.CtrlKey && e.AltKey) {
            switch(e.Code) {
                case "KeyA":
                    player1File = selectedFile;
                    shouldRender = true;
                    break;
                case "KeyB":
                    player2File = selectedFile;
                    shouldRender = true;
                    break;
                case "KeyS":
                    OpenSettingsDialog();
                    break;
            }
        }
    }

    private void HandleKeyUp(KeyboardEventArgs e) {
        mouseState.ShiftDown = e.ShiftKey;
    }

    private void OpenSettingsDialog() {
        SetPlayersMouseCapturing(false);
        enableMidiEvents = false;
        settingsComponent.Open();
    }

    private void HandleMouseDown(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
        mouseState.ButtonsDown = e.Buttons;
    }

    private void HandleMouseMove(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
    }

    private void HandleMouseUp(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
        mouseState.ButtonsDown = e.Buttons;
    }

    private void HandleMouseWheel(WheelEventArgs e) {
        mouseState.WheelDelta = e.DeltaY;
    }

    private void HandleDividerResize((string name, double value) args) {
        if(Program.Settings.UIElements.ContainsKey(args.name)) {
            Program.Settings.UIElements[args.name] = args.value.ToString();
        } else {
            Program.Settings.UIElements.Add(args.name, args.value.ToString());
        }
    }

    private void ApplyMonitorMix(double value) {

    }

    private void ApplyMainGain(double value) {
        value *= 2; // 0-1 to 0-2 range
        player1?.SetGain((float)value);
        player2?.SetGain((float)value);
    }

    private CancellationTokenSource? cancellationTokenSource = null;
    private Task? crossfadeTask = null;
    private void HandleAutoCrossFade(int direction) {
        if(crossFader == null) return;

        if(cancellationTokenSource == null) {
            cancellationTokenSource = new CancellationTokenSource();
        } else {
            cancellationTokenSource.Cancel();
            crossfadeTask?.Wait();
            cancellationTokenSource.Dispose();
            cancellationTokenSource = new CancellationTokenSource();
        }

        int duration = 2; // seconds
        crossfadeTask = Task.Run(async () => {
            while(!cancellationTokenSource.IsCancellationRequested) {
                double value = crossFader.Value - direction / 100.0;
                if(value < 0 || value > 1) break;
                await crossFader.SetValue(value, true);
                await Task.Delay(10 * duration);
            }
        }, cancellationTokenSource.Token);
    }

    private void ApplyCrossfaderVolume(double value) {
        player1?.SetCrossFaderVolume(value >= 0.5 ? 1 : 2 * value);
        player2?.SetCrossFaderVolume(value <= 0.5 ? 1 : 2 * (1 - value));
    }

    private void SetMediaProviders() {
        this.mediaProviders.Clear();

        foreach(Diyokee.Settings.MediaProvider mp in Program.Settings.MediaProviders) {
            if(mp.Type == "local") { // We only support local/netshare paths for now
                MediaProviderLocal nmp = new(mp.Name,
                                            string.IsNullOrEmpty(mp.RootDirectory)
                                                ? MediaProviderLocal.DefaultDirectory
                                                : mp.RootDirectory,
                                            mp.InitialPath);
                this.mediaProviders.Add(nmp);
            }
        }

        if(this.mediaProviders.Count == 0) {
            MediaProviderLocal nmp = new("default", MediaProviderLocal.DefaultDirectory);
            //throw new Exception("No valid media providers found");
        } else {
            selectedMediaProvider = this.mediaProviders[0];
        }
    }

    private async void UpdateApp() {
        EqualizerProfile equalizerProfile = Program.Settings.EqualizerProfiles.FirstOrDefault(p => p.Name == Program.Settings.Playback.EqProfile) ?? Program.Settings.EqualizerProfiles[0];
        player1!.EqControls.EqProfile = equalizerProfile;
        player1!.SetTempoRange(Program.Settings.Playback.TempoRange);

        player2!.EqControls.EqProfile = equalizerProfile;
        player2!.SetTempoRange(Program.Settings.Playback.TempoRange);

        SetMediaProviders();

        await JS.InvokeVoidAsync("forceRefresh");

        shouldRender = true;
        await InvokeAsync(StateHasChanged);
    }

    private void SetPlayersMouseCapturing(bool state) {
        player1!.EnableMouseEvents = state;
        player2!.EnableMouseEvents = state;
    }

    protected override bool ShouldRender() {
        if(shouldRender) {
            shouldRender = false;
            return true;
        }
        return false;
    }

    private bool IsPlaying => player1!.IsPlaying || player2!.IsPlaying;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender) {
            await Task.Delay(500);

            string? folder = session.Get<string>(nameof(selectedFolder));
            if(folder != null && folder != "") {
                SelectedFolderChanged(folder);
                await InvokeAsync(StateHasChanged);
            }

            DFile? file = session.Get<DFile>(nameof(selectedFile));
            if(file != null) filesComponent?.ChangeSelectedFile(file);

            MidiMonitor();

            // =====================================

            // KeyTools keyTools = new();

            // BASS_MIDI_DEVICEINFO[] info = BassMidi.BASS_MIDI_InGetGeviceInfos();
            // var err = Bass.BASS_ErrorGetCode();
            // for(int i = 0; i < info.Length; i++) {
            //     Debug.WriteLine($"MIDI IN Device {i}: {info[i].name}");

            //     var midiStream = BassMidi.BASS_MIDI_StreamCreate(16, 0, 0);

            //     midiProc = (device, time, buffer, length, user) => {
            //         byte[] bytes = new byte[length];
            //         System.Runtime.InteropServices.Marshal.Copy(buffer, bytes, 0, length);

            //         BASS_MIDI_EVENT[] midiEvents = BassMidi.BASS_MIDI_ConvertEvents(bytes, BASSMIDIEventMode.BASS_MIDI_EVENTS_STRUCT);
            //         if(midiEvents != null) {
            //             foreach(BASS_MIDI_EVENT midiEvent in midiEvents) {
            //                 Debug.Write($"MIDI Event {midiEvent.eventtype}: ");

            //                 if(midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE) {
            //                     int keyNumber = (midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE) ? midiEvent.param & 0xFF : -1;
            //                     int keyVelocity = (midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE) ? (midiEvent.param >> 8) & 0xFF : -1;

            //                     string key = keyTools.FromMidiNote(keyNumber, KeyTools.Notations.American, true);

            //                     if(keyVelocity > 0) {
            //                         double trackKeyNumber = keyTools.ToMidiNote(player1?.File.Key ?? key);

            //                         player1?.SetPitch(keyNumber - trackKeyNumber);
            //                         player1?.Play(false);
            //                     } else {
            //                         player1?.Stop(true);
            //                     }

            //                     Debug.Write($"Note: {key,3} | Freq: {keyTools.MidiNoteToFrequency(keyNumber),8:N2} | Velocity: {keyVelocity,4}");
            //                     Debug.Write($" | Key: {keyTools.ToMidiNote(key),4}");

            //                     Debug.Write($"Param: {midiEvent.param,5} | Note: {keyNumber,3} | Velocity: {keyVelocity,4}");
            //                 } else {
            //                     Debug.Write($"Param: {midiEvent.param,5}");
            //                 }

            //                 Debug.WriteLine($" | Channel: {midiEvent.chan,2} | Tick: {midiEvent.tick,4} | Pos: {midiEvent.pos,5}");
            //             }
            //         }

            //         BassMidi.BASS_MIDI_StreamEvents(midiStream, BASSMIDIEventMode.BASS_MIDI_EVENTS_RAW, 0, buffer, length);
            //     };

            //     bool r1 = BassMidi.BASS_MIDI_InInit(i, midiProc, IntPtr.Zero);
            //     var err1 = Bass.BASS_ErrorGetCode();
            //     bool r2 = BassMidi.BASS_MIDI_InStart(i);
            //     var err2 = Bass.BASS_ErrorGetCode();
            // }
        }

        await InvokeAsync(StateHasChanged); // This updates the SYNC->PLAYER buttons
    }

    private void MidiMonitor() {
        bool navigateFolders = true;

        Program.MidiTools.OnMidiEvent += (string propertyName, string section, MidiControllerProfile.MidiMapping mapping, BASS_MIDI_EVENT midiEvent) => {
            if(!enableMidiEvents) return;

            //Console.WriteLine(propertyName);
            int velocity = (midiEvent.param >> 8) & 0xFF;

            switch(propertyName) {
                case "FoldersFilesToggle":
                    navigateFolders = !navigateFolders;
                    if(!navigateFolders) {
                        InvokeAsync(filesComponent!.SelectDown);
                        InvokeAsync(filesComponent!.SelectUp);
                    }
                    return;
                case "ExpandFolder":
                    InvokeAsync(mediaProviderContainerUI!.FoldersUI!.ExpandSelectedFolder);
                    return;
                case "LoadSelectedFileToPlayer0":
                    player1File = selectedFile;
                    shouldRender = true;
                    if(!IsPlaying) InvokeAsync(StateHasChanged);
                    return;
                case "LoadSelectedFileToPlayer1":
                    player2File = selectedFile;
                    shouldRender = true;
                    if(!IsPlaying) InvokeAsync(StateHasChanged);
                    return;
                case "Crossfader":
                    double crossfaderValue = 1.0 - midiEvent.param / 127.0;
                    InvokeAsync(() => crossFader!.SetValue(crossfaderValue, true));
                    return;
                case "BrowseUp":
                    if(mapping.Parameter != midiEvent.param) return;
                    if(navigateFolders) {
                        InvokeAsync(mediaProviderContainerUI!.FoldersUI!.SelectUp);
                    } else {
                        InvokeAsync(filesComponent!.SelectUp);
                    }
                    return;
                case "BrowseDown":
                    if(mapping.Parameter != midiEvent.param) return;
                    if(navigateFolders) {
                        InvokeAsync(mediaProviderContainerUI!.FoldersUI!.SelectDown);
                    } else {
                        InvokeAsync(filesComponent!.SelectDown);
                    }
                    return;
                case "Gain":
                    double gainValue = ((midiEvent.param >> 8) & 0xFF) / 127.0;
                    InvokeAsync(() => mainGain!.SetValue(gainValue, true));
                    return;
            }

            Player? targetPlayer = null;
            if(section == "player0") targetPlayer = player1;
            else if(section == "player1") targetPlayer = player2;
            if(targetPlayer == null) return;

            bool isControlEvent = midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_CONTROL;
            double value = isControlEvent ? ((midiEvent.param >> 8) & 0xFF) / 127.0 : midiEvent.param / 127.0;

            switch(propertyName) {
                case "PlayPause":
                    if(velocity > 0) targetPlayer.Play(targetPlayer.SnapToBeatMarkers && Program.Settings.Playback.SyncPlayback);
                    return;
                case "Stop":
                    if(velocity > 0) targetPlayer.Stop(false);
                    return;
                case "Cue":
                    if(velocity > 0) {
                        targetPlayer.Play(targetPlayer.SnapToBeatMarkers && Program.Settings.Playback.SyncPlayback);
                    } else {
                        targetPlayer.Stop(true);
                    }
                    return;
                case "LoopJumpLockToggle":
                    if(velocity > 0) targetPlayer.ToggleLoopJumpSync();
                    return;
                case "LoopToggle":
                    if(velocity > 0) targetPlayer.ToggleLoop();
                    return;
                case "LoopSizeIncrease":
                    if(velocity > 0) targetPlayer.LoopSizeIncrease();
                    return;
                case "LoopSizeDecrease":
                    if(velocity > 0) targetPlayer.LoopSizeDecrease();
                    return;
                case "JumpSizeIncrease":
                    if(velocity > 0) targetPlayer.JumpSizeIncrease();
                    return;
                case "JumpSizeDecrease":
                    if(velocity > 0) targetPlayer.JumpSizeDecrease();
                    return;
                case "SnapToBeatMarker":
                    if(velocity > 0) targetPlayer.SnapToClosestBeatMarker();
                    return;
                case "Volume":
                    double volume = value;
                    InvokeAsync(() => targetPlayer.SetVolume(volume));
                    return;
                case "EqHi":
                    InvokeAsync(() => {
                        targetPlayer?.EqControls.ApplyEqHi(value);
                        targetPlayer?.EqControls.UpdateKnobs();
                    });
                    return;
                case "EqMid":
                    InvokeAsync(() => {
                        targetPlayer?.EqControls.ApplyEqMid(value);
                        targetPlayer?.EqControls.UpdateKnobs();
                    });
                    return;
                case "EqLow":
                    InvokeAsync(() => {
                        targetPlayer?.EqControls.ApplyEqLow(value);
                        targetPlayer?.EqControls.UpdateKnobs();
                    });
                    return;
                case "Color":
                    targetPlayer.FilterControls.FiltersValues.Color = value;
                    InvokeAsync(targetPlayer.FilterControls.UpdateKnobs);
                    return;
                case "JogWheelForward":
                    if(mapping.Velocity == ((midiEvent.param >> 8) & 0xFF)) targetPlayer?.JogWheelForward();
                    return;
                case "JogWheelBackward":
                    if(mapping.Velocity == ((midiEvent.param >> 8) & 0xFF)) targetPlayer?.JogWheelBackward();
                    return;
                case "Tempo":
                    double tempo = 1.0 - value;
                    InvokeAsync(() => targetPlayer.SetTempo(tempo));
                    return;
                case "BpmMatch": {
                    InvokeAsync(targetPlayer.SyncBPMToOtherPlayer);
                    return;
                }
            }
        };

        Program.MidiTools.Start();
    }
}