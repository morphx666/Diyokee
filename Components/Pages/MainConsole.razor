@using Diyokee
@using Diyokee.MediaProviders
@using Newtonsoft.Json
@using System.Diagnostics
@using Un4seen.Bass
@using Un4seen.Bass.AddOn.Mix
@using Un4seen.Bass.AddOn.Midi
@using static Diyokee.Settings
@inject IJSRuntime JS
@inject SessionState session

@page "/"

<PageTitle>Diyokee</PageTitle>

<div class="main-console"
     tabindex="0"
     @onkeydown="HandleKeyDown"
     @onkeydown:preventDefault="false"
     @onkeyup="HandleKeyUp"
     @onkeyup:preventDefault="false"
     @onmousedown="HandleMouseDown"
     @onmousemove="HandleMouseMove"
     @onmouseup="HandleMouseUp"
     @onmousewheel="HandleMouseWheel"
     @onwheel="HandleMouseWheel">
    <CascadingValue Value="@mouseState">
        <div class="players" @ref="playersPanel">
            <div class="player">
                <Player
                    Settings="Program.Settings.Playback.Players[0]"
                    File="@player1File"
                    RequestedFileCue="() => LoadSelectedFile(player1)"
                    OtherPlayer="@player2"
                    @ref="player1" />
            </div>

            <div class="global-controls">
                <Knob Name="GAIN" @ref="mainGain" RangeFromCenter="false" ValueChanged="ApplyMainGain" />
                <div class="button-thin" @onclick="OpenSettingsDialog"><i class="fa-solid fa-gear"></i></div>
            </div>

            <div class="player">
                <Player
                    Settings="Program.Settings.Playback.Players[1]"
                    File="@player2File"
                    RequestedFileCue="() => LoadSelectedFile(player2)"
                    OtherPlayer="@player1"
                    @ref="player2" />
            </div>
        </div>

        @if(Program.Settings.Playback.BeatmatchingDisplay) {
            <div class="beatmatching">
                <BeatMatching
                Player1="player1"
                Player2="player2"
                />
            </div>
        }

        <div class="mixer" @ref="mixerPanel">
            <div class="crossfade-controls">
                <div class="button-3d" @onclick="() => HandleAutoCrossFade(-1)"><i class="fa-solid fa-caret-left"></i></div>
                <Fader Orientation="Fader.Orientations.Horizontal" ValueChanged="ApplyCrossfaderVolume" DefaultValue="0.5" @ref="crossFader" />
                <div class="button-3d" @onclick="() => HandleAutoCrossFade(+1)"><i class="fa-solid fa-caret-right"></i></div>
            </div>
            <div class="monitor-controls">
                <Knob Name="Volume" @ref="monitorVolume" RangeFromCenter="false" ValueChanged="ApplyMonitorVolume" />
                <i class="fa-solid fa-volume-high"></i>
                <Knob Name="Mix" @ref="monitorMix" ValueChanged="ApplyMonitorMix" />
                <i class="fa-solid fa-headphones-simple"></i>
            </div>
        </div>

        <PanelResize
            Orientation="PanelResize.Orientations.Vertical"
            ResizeElement="playersPanel"
            ElementsBetween="new() { mixerPanel }"
            Name="main-resize-vertical"
            OnResizeEnd="HandleDividerResize"
            Constrains="playersConstrains" />

        <div class="media">
            <div class="media-providers" @ref="mediaProviderPanel">
                <div class="tabs">
                    @foreach(IMediaProvider provider in mediaProviders) {
                        <div class="tab @(selectedMediaProvider == provider ? "selected" : "")"
                             @onclick="() => {
                             selectedMediaProvider = provider;
                             // FIXME: Hopefully we can find an easier way to do this...
                             selectedMediaProvider.InitialPath = Program.Settings.MediaProviders.Where(mp => mp.Name == provider.Name).First().InitialPath;
                             SelectedFolderChanged(provider.RootPath);
                             shouldRender = true;
                         }">
                        @provider.Name
                    </div>
                                        }
                </div>

                <div class="sources panel">
                    <MediaProviderContainer
                        Provider="@selectedMediaProvider"
                        SelectedFolderChanged="SelectedFolderChanged"
                        @ref="mediaProviderContainerUI" />
                </div>
            </div>

            <PanelResize
                Orientation="PanelResize.Orientations.Horizontal"
                ResizeElement="mediaProviderPanel"
                Name="main-resize-horizontal"
                OnResizeEnd="HandleDividerResize"
                Constrains="mediaProviderConstrains" />

            <Files
                Provider="@selectedMediaProvider"
                RelativePath="@selectedFolder"
                SelectedFileChanged="SelectedFileChanged"
                TrackSettingsDialogOpened="() => SetPlayersMouseCapturing(false)"
                TrackSettingsDialogClosed="() => SetPlayersMouseCapturing(true)"
                @ref="filesComponent" />
        </div>

        @if(showSettingsDialog) {
            <Settings
                OnSave="() => CloseSettingsDialog(true)"
                OnClose="() => CloseSettingsDialog(false)" />
        }
    </CascadingValue>
</div>

@code {
    private List<IMediaProvider> mediaProviders = new();
    private IMediaProvider? selectedMediaProvider;
    private string selectedFolder = "";

    private DFile? selectedFile = null;
    private DFile? player1File = null;
    private DFile? player2File = null;

    private Files? filesComponent;
    private MediaProviderContainer? mediaProviderContainerUI;

    private Player? player1;
    private Player? player2;
    private Fader? crossFader;

    private bool showSettingsDialog = false;
    private MouseState mouseState = new();

    private ElementReference playersPanel;
    private ElementReference mixerPanel;
    private Dictionary<PanelResize.ConstrainKeys, string> playersConstrains = new() { { PanelResize.ConstrainKeys.Min, "420" } };
    private ElementReference mediaProviderPanel;
    private Dictionary<PanelResize.ConstrainKeys, string> mediaProviderConstrains = new() { { PanelResize.ConstrainKeys.Min, "250" } };

    private Knob? monitorMix = null!;
    private Knob? monitorVolume = null!;
    private Knob? mainGain = null!;

    private bool shouldRender = true;
    private bool enableMidiEvents = true;

    private Dictionary<string, string> CssVariables = [];

    private void LoadSelectedFile(Player? player) {
        if(player!.IsPlaying && Program.Settings.Playback.LockOnPlay) return;

        if(player == player1) {
            player1File = selectedFile;
        } else if(player == player2) {
            player2File = selectedFile;
        }
        shouldRender = true;
    }

    private void SelectedFolderChanged(string folder) {
        if(selectedMediaProvider == null) return;

        Program.Settings.MediaProviders.ForEach(mp => {
            if(mp.Name == selectedMediaProvider.Name) {
                mp.InitialPath = selectedMediaProvider.RootPath == folder ? "" : folder;
            }
        });
        selectedFolder = folder;
        shouldRender = true;

        session.Set(nameof(selectedFolder), folder);
    }

    private void SelectedFileChanged(DFile file) {
        selectedFile = file;
        shouldRender = true;

        if(player1!.File?.Filename == file.Filename) player1File = selectedFile;
        if(player2!.File?.Filename == file.Filename) player2File = selectedFile;

        session.Set(nameof(selectedFile), file);
    }

    private void HandleKeyDown(KeyboardEventArgs e) {
        mouseState.ShiftDown = e.ShiftKey;
        if(e.CtrlKey && e.AltKey) {
            switch(e.Code) {
                case "KeyA":
                    player1File = selectedFile;
                    shouldRender = true;
                    break;
                case "KeyB":
                    player2File = selectedFile;
                    shouldRender = true;
                    break;
                case "KeyS":
                    OpenSettingsDialog();
                    break;
            }
        }
    }

    private void HandleKeyUp(KeyboardEventArgs e) {
        mouseState.ShiftDown = e.ShiftKey;
    }

    private void OpenSettingsDialog() {
        SetPlayersMouseCapturing(false);
        enableMidiEvents = false;
        showSettingsDialog = true;

        shouldRender = true;
        InvokeAsync(StateHasChanged);
    }

    private void HandleMouseDown(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
        mouseState.ButtonsDown = e.Buttons;
    }

    private void HandleMouseMove(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
    }

    private void HandleMouseUp(MouseEventArgs e) {
        mouseState.X = e.ClientX;
        mouseState.Y = e.ClientY;
        mouseState.ButtonsDown = e.Buttons;
    }

    private void HandleMouseWheel(WheelEventArgs e) {
        mouseState.WheelDelta = e.DeltaY;
    }

    private void HandleDividerResize((string name, double value) args) {
        if(Program.Settings.UIElements.ContainsKey(args.name)) {
            Program.Settings.UIElements[args.name] = args.value.ToString();
        } else {
            Program.Settings.UIElements.Add(args.name, args.value.ToString());
        }
    }

    private void ApplyMonitorVolume(double value) {
        monitorVolume?.SetValue(value);
        player1?.SetMonitorVolume(value);
        player2?.SetMonitorVolume(value);
    }

    private void ApplyMonitorMix(double value) {
        monitorMix?.SetValue(value);
        player1?.SetMonitorMix(value);
        player2?.SetMonitorMix(value);
    }

    private void ApplyMainGain(double value) {
        mainGain?.SetValue(value);
        value *= 2; // 0-1 to 0-2 range
        player1?.SetGain((float)value);
        player2?.SetGain((float)value);
    }

    private CancellationTokenSource? cancellationTokenSource = null;
    private Task? crossfadeTask = null;
    private void HandleAutoCrossFade(int direction) {
        if(crossFader == null) return;

        if(cancellationTokenSource == null) {
            cancellationTokenSource = new CancellationTokenSource();
        } else {
            cancellationTokenSource.Cancel();
            crossfadeTask?.Wait();
            cancellationTokenSource.Dispose();
            cancellationTokenSource = new CancellationTokenSource();
        }

        int duration = 2; // seconds
        crossfadeTask = Task.Run(async () => {
            while(!cancellationTokenSource.IsCancellationRequested) {
                double value = crossFader.Value - direction / 100.0;
                if(value < 0 || value > 1) break;
                await crossFader.SetValue(value, true);
                await Task.Delay(10 * duration);
            }
        }, cancellationTokenSource.Token);
    }

    private void ApplyCrossfaderVolume(double value) {
        player1?.SetCrossFaderVolume(value >= 0.5 ? 1 : 2 * value);
        player2?.SetCrossFaderVolume(value <= 0.5 ? 1 : 2 * (1 - value));
    }

    private void SetMediaProviders() {
        this.mediaProviders.Clear();

        foreach(Diyokee.Settings.MediaProvider mp in Program.Settings.MediaProviders) {
            if(mp.Type == "local") { // We only support local/netshare paths for now
                MediaProviderLocal nmp = new(mp.Name,
                                            string.IsNullOrEmpty(mp.RootDirectory)
                                                ? MediaProviderLocal.DefaultDirectory
                                                : mp.RootDirectory,
                                            mp.InitialPath);
                this.mediaProviders.Add(nmp);
            }
        }

        if(this.mediaProviders.Count == 0) {
            MediaProviderLocal nmp = new("default", MediaProviderLocal.DefaultDirectory);
            //throw new Exception("No valid media providers found");
        } else {
            selectedMediaProvider = this.mediaProviders[0];
        }
    }

    private async void CloseSettingsDialog(bool update) {
        if(update) {
            EqualizerProfile equalizerProfile = Program.Settings.EqualizerProfiles.FirstOrDefault(p => p.Name == Program.Settings.Playback.EqProfile) ?? Program.Settings.EqualizerProfiles[0];
            player1!.EqControls.EqProfile = equalizerProfile;
            player1!.SetTempoRange(Program.Settings.Playback.TempoRange);

            player2!.EqControls.EqProfile = equalizerProfile;
            player2!.SetTempoRange(Program.Settings.Playback.TempoRange);

            SetMediaProviders();

            await JS.InvokeVoidAsync("forceRefresh");
        }

        SetPlayersMouseCapturing(true);
        enableMidiEvents = true;
        showSettingsDialog = false;

        shouldRender = true;
        await InvokeAsync(StateHasChanged);
    }

    private void SetPlayersMouseCapturing(bool state) {
        player1!.EnableMouseEvents = state;
        player2!.EnableMouseEvents = state;
    }

    protected override bool ShouldRender() {
        if(shouldRender) {
            shouldRender = false;
            return true;
        }
        return false;
    }

    private bool IsPlaying => player1!.IsPlaying || player2!.IsPlaying;

    private void MidiMonitor() {
        bool navigateFolders = true;
        KeyTools keyTools = new();
        List<int> pressedKeys = [];

        Program.MidiTools.OnMidiEvent += (string propertyName, string section, MidiControllerProfile.MidiMapping mapping, BASS_MIDI_EVENT midiEvent) => {
            if(!enableMidiEvents) return;

            int velocity = (midiEvent.param >> 8) & 0xFF;

            if(section == "general") {
                switch(propertyName) {
                    case "FoldersFilesToggle":
                        navigateFolders = !navigateFolders;
                        if(!navigateFolders) {
                            InvokeAsync(filesComponent!.SelectDown);
                            InvokeAsync(filesComponent!.SelectUp);
                        }
                        return;
                    case "ExpandFolder":
                        InvokeAsync(mediaProviderContainerUI!.FoldersUI!.ExpandSelectedFolder);
                        return;
                    case "LoadSelectedFileToPlayer0":
                        player1File = selectedFile;
                        shouldRender = true;
                        if(!IsPlaying) InvokeAsync(StateHasChanged);
                        return;
                    case "LoadSelectedFileToPlayer1":
                        player2File = selectedFile;
                        shouldRender = true;
                        if(!IsPlaying) InvokeAsync(StateHasChanged);
                        return;
                    case "Crossfader":
                        double crossfaderValue = 1.0 - midiEvent.param / 127.0;
                        InvokeAsync(() => crossFader!.SetValue(crossfaderValue, true));
                        return;
                    case "BrowseUp":
                        if(mapping.Parameter != midiEvent.param) return;
                        if(navigateFolders) {
                            InvokeAsync(mediaProviderContainerUI!.FoldersUI!.SelectUp);
                        } else {
                            InvokeAsync(filesComponent!.SelectUp);
                        }
                        return;
                    case "BrowseDown":
                        if(mapping.Parameter != midiEvent.param) return;
                        if(navigateFolders) {
                            InvokeAsync(mediaProviderContainerUI!.FoldersUI!.SelectDown);
                        } else {
                            InvokeAsync(filesComponent!.SelectDown);
                        }
                        return;
                    case "Gain":
                        double gainValue = ((midiEvent.param >> 8) & 0xFF) / 127.0;
                        InvokeAsync(() => mainGain!.SetValue(gainValue, true));
                        return;
                }
            }

            if(section.StartsWith("player")) {
                Player? targetPlayer = null;
                if(section == "player0") targetPlayer = player1;
                else if(section == "player1") targetPlayer = player2;
                if(targetPlayer == null) return;

                bool isControlEvent = midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_CONTROL;
                double value = isControlEvent ? ((midiEvent.param >> 8) & 0xFF) / 127.0 : midiEvent.param / 127.0;

                var PlayerAction = (Action fcn) => {
                    if(velocity > 0) {
                        fcn();
                        shouldRender = true;
                        InvokeAsync(StateHasChanged);
                    }
                };

                switch(propertyName) {
                    case "PlayPause":
                        if(velocity > 0) targetPlayer.Play(targetPlayer.SnapToBeatMarkers && Program.Settings.Playback.SyncPlayback);
                        return;
                    case "Stop":
                        if(velocity > 0) targetPlayer.Stop(false);
                        return;
                    case "Cue":
                        if(velocity > 0) {
                            targetPlayer.Play(targetPlayer.SnapToBeatMarkers && Program.Settings.Playback.SyncPlayback);
                        } else {
                            targetPlayer.Stop(true);
                        }
                        return;
                    case "LoopJumpLockToggle":
                        PlayerAction(targetPlayer.ToggleLoopJumpSync);
                        return;
                    case "LoopToggle":
                        PlayerAction(targetPlayer.ToggleLoop);
                        return;
                    case "LoopSizeIncrease":
                        PlayerAction(targetPlayer.LoopSizeIncrease);
                        return;
                    case "LoopSizeDecrease":
                        PlayerAction(targetPlayer.LoopSizeDecrease);
                        return;
                    case "JumpSizeIncrease":
                        PlayerAction(targetPlayer.JumpSizeIncrease);
                        return;
                    case "JumpSizeDecrease":
                        PlayerAction(targetPlayer.JumpSizeDecrease);
                        return;
                    case "SnapToBeatMarker":
                        PlayerAction(targetPlayer.SnapToClosestBeatMarker);
                        return;
                    case "Volume":
                        double volume = value;
                        InvokeAsync(() => targetPlayer.SetTrackVolume(volume));
                        return;
                    case "EqHi":
                        InvokeAsync(() => {
                            targetPlayer.EqControls.ApplyEqHi(value);
                            targetPlayer.EqControls.UpdateKnobs();
                        });
                        return;
                    case "EqMid":
                        InvokeAsync(() => {
                            targetPlayer.EqControls.ApplyEqMid(value);
                            targetPlayer.EqControls.UpdateKnobs();
                        });
                        return;
                    case "EqLow":
                        InvokeAsync(() => {
                            targetPlayer.EqControls.ApplyEqLow(value);
                            targetPlayer.EqControls.UpdateKnobs();
                        });
                        return;
                    case "Color":
                        targetPlayer.FilterControls.FiltersValues.Color = value;
                        InvokeAsync(targetPlayer.FilterControls.UpdateKnobs);
                        return;
                    case "JogWheelForward":
                        if(mapping.Velocity == ((midiEvent.param >> 8) & 0xFF)) targetPlayer.JogWheelForward();
                        return;
                    case "JogWheelBackward":
                        if(mapping.Velocity == ((midiEvent.param >> 8) & 0xFF)) targetPlayer.JogWheelBackward();
                        return;
                    case "Tempo":
                        double tempo = 1.0 - value;
                        InvokeAsync(() => targetPlayer.SetTempo(tempo));
                        return;
                    case "BpmMatch": {
                        InvokeAsync(targetPlayer.SyncBPMToOtherPlayer);
                        return;
                    }
                }
            }

            if(section == "keyboard") {
                double pitch = 0;

                switch(propertyName) {
                    case "Volume":
                        if(player1 == null) return;

                        double volume = midiEvent.param / 127.0;
                        InvokeAsync(() => player1.SetTrackVolume(volume));
                        return;
                    case "Pitch":
                        if(player1 == null) return;

                        pitch = (midiEvent.param - 8192) / 8192.0 * 12.0; // +/- 12 semitones
                        player1.SetPitch(pitch);
                        player1.FilterControls.FiltersValues.Key = pitch / 12.0 + 0.5;
                        InvokeAsync(player1.FilterControls.UpdateKnobs);
                        shouldRender = true;
                        InvokeAsync(StateHasChanged);
                        return;
                    default:
                        if(midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE) {
                            if(player1 == null || player1.File == null) return;

                            int keyNumber = midiEvent.param & 0xFF;
                            int keyVelocity = (midiEvent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE) ? (midiEvent.param >> 8) & 0xFF : -1;

                            if(keyVelocity > 0) {
                                string key = keyTools.FromMidiNote(keyNumber, KeyTools.Notations.American, true);
                                double trackKeyNumber = keyTools.ToMidiNote(player1.File.Key ?? key);
                                pitch = keyNumber - trackKeyNumber;

                                if(player1.IsPlaying) player1.Stop(true); // Force no polyphony

                                player1.SetPitch(pitch);
                                player1.FilterControls.FiltersValues.Key = pitch / 12.0 + 0.5;
                                player1.Play(false);

                                pressedKeys.Add(keyNumber);
                            } else {
                                int lastIndex = pressedKeys.LastIndexOf(keyNumber);
                                if(lastIndex >= 0) pressedKeys.RemoveAt(lastIndex);
                                if(pressedKeys.Count == 0) {
                                    player1.FilterControls.FiltersValues.Key = 0.5;
                                    player1.Stop(true);
                                }
                            }

                            // FIXME: This looks like will cause way too many re-renders
                            InvokeAsync(player1.FilterControls.UpdateKnobs);
                            shouldRender = true;
                            InvokeAsync(StateHasChanged);
                        }
                        return;
                }
            }
        };

        Program.MidiTools.Start();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender) {
            SetMediaProviders();

            await Task.Delay(500);

            string? folder = session.Get<string>(nameof(selectedFolder));
            if(folder != null && folder != "") {
                SelectedFolderChanged(folder);
                await InvokeAsync(StateHasChanged);
            }

            DFile? file = session.Get<DFile>(nameof(selectedFile));
            if(file != null) filesComponent?.ChangeSelectedFile(file);

            while(true) {
                await Task.Delay(250);

                if(player1 != null && player2 != null) {
                    monitorVolume?.SetInitialValue(0.0);
                    ApplyMonitorVolume(0.0);
                    ApplyMonitorMix(0.5);
                    ApplyMainGain(0.5);

                    break;
                }
            }

            // TODO: Not sure what to do with this yet... maybe implement a theme editor?
            using(HttpClient client = new()) {
                string appCss = await client.GetStringAsync($"{Program.Settings.WebHostUrl}/{Assets["app.css"]}");
                string[] lines = appCss.Split('\n');

                for(int i = 0; i < lines.Length; i++) {
                    string line = lines[i].Trim();
                    if(line.StartsWith("--")) {
                        int colonIndex = line.IndexOf(':');
                        if(colonIndex > 0) {
                            string key = line.Substring(0, colonIndex).Trim();
                            string value = line.Substring(colonIndex + 1).Trim().TrimEnd(';');
                            if(value.Contains(";")) value = value.Split(';')[0].Trim();
                            CssVariables[key] = value;
                        }
                    }
                }
            }

            MidiMonitor();
        }

        await InvokeAsync(StateHasChanged);
    }
}