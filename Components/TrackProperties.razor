@using Diyokee.Data
@using Microsoft.EntityFrameworkCore
@using static Diyokee.Settings
@inject IDbContextFactory<CacheDbContext> CacheDbContextFactory;
@inject IJSRuntime JS

<ModalDialog
    @ref="dialog"
    Title="Track Properties"
    OnClose="Close"
    OnSave="Save"
    Movable=true>
    <div class="field">
        <label for="artist">Artist</label>
        <InputText id="artist" @bind-value="File.Artist" />
    </div>

    <div class="field">
        <label for="title">Title</label>
        <InputText id="title" @bind-value="File.Title" />
    </div>

    <div class="row">
        <div class="field"
            tabindex="0"
            @onblur="@(() => {
                albumsAcVisible = false;
                player?.EnableMouseEvents = true;
            })">
            <label for="album">Album</label>
            <div
                class="select-container"
                @onclick="@(async (e) => {
                    albumsAcVisible = true;
                    player?.EnableMouseEvents = false;
                    await JS.InvokeVoidAsync("scrollToSelectedItem");
                })">
                <InputText id="album"
                    @bind-value="File.Album"
                />
                <div class="autocomplete scroller @(albumsAcVisible ? "show" : "")">
                    @foreach(var album in albums) {
                        <div
                            class="item @(album == File.Album ? "selected" : "")"
                            @onclick:stopPropagation="true"
                            @onclick="@(async () => {
                                    File.Album = album;
                                    albumsAcVisible = false;
                                    player?.EnableMouseEvents = true;
                                })">
                            @album
                        </div>
                    }
                </div>
            </div>
        </div>

        <div class="field"
            tabindex="1"
            @onblur="@(() => {
                genresAcVisible = false;
                player?.EnableMouseEvents = true;
            })">
            <label for="genre" class="no-min-size">Genre</label>
            <div
                class="select-container"
                @onclick="@(async () => {
                    genresAcVisible = true;
                    player?.EnableMouseEvents = false;
                    await JS.InvokeVoidAsync("scrollToSelectedItem");
                })">
                <InputText id="genre"
                    @bind-value="File.Genre"
                />
                <div class="autocomplete scroller @(genresAcVisible ? "show" : "")">
                    @foreach(var genre in genres) {
                        <div
                            class="item @(genre == File.Genre ? "selected" : "")"
                            @onclick:stopPropagation="true"
                            @onclick="@(async () => {
                                    File.Genre = genre;
                                    genresAcVisible = false;
                                    player?.EnableMouseEvents = true;
                                })">
                            @genre
                        </div>
                    }
                </div>
            </div>
        </div>

        <div class="field year">
            <label for="year" class="no-min-size">Year</label>
            <InputNumber id="year" @bind-value="File.Year" />
        </div>
    </div>

    <div class="row">
        <div class="inner-properties-container">
            <div class="field bpm-container">
                <label>Downbeat</label>
                <div class="field downbeat">
                    <InputNumber id="downbeatH" @bind-value="DownbeatAtHours" @oninput="(e) => DownbeatAtHours = int.TryParse(e.Value?.ToString() ?? string.Empty, out var hours) ? hours : 0" hidden="true" /><span hidden="true">:</span>
                    <InputNumber id="downbeatM" @bind-value="DownbeatAtMinutes" @oninput="(e) => DownbeatAtMinutes = int.TryParse(e.Value?.ToString() ?? string.Empty, out var minutes) ? minutes : 0" /><span>:</span>
                    <InputNumber id="downbeatM" @bind-value="DownbeatAtSeconds" @oninput="(e) => DownbeatAtSeconds = int.TryParse(e.Value?.ToString() ?? string.Empty, out var seconds) ? seconds : 0" /><span>:</span>
                    <InputNumber id="downbeatMs" @bind-value="DownbeatAtMilliSeconds" @oninput="(e) => DownbeatAtMilliSeconds = int.TryParse(e.Value?.ToString() ?? string.Empty, out var ms) ? ms : 0" />
                </div>
                <div class="recalculate" @onclick="ReCalcDownbeat"><i class="fa-solid fa-arrow-rotate-right"></i></div>
                <div class="recalculate" @onclick="ReSetDownbeat"><i class="fa-solid fa-arrow-turn-up"></i></div>
            </div>

            <div class="field bpm-container">
                <label for"bpm">BPM</label>
                <InputNumber id="bpm" class="as-number" @bind-value="BPM" @oninput="(e) => BPM = float.TryParse(e.Value?.ToString() ?? string.Empty, out var bpm) ? bpm : 0" />
                <div class="recalculate" @onclick="ReCalcBpm"><i class="fa-solid fa-arrow-rotate-right"></i></div>
                <div class="recalculate" @onclick="() => BpmMultiply(2.0)"><i class="fa-solid fa-xmark"></i>2</div>
                <div class="recalculate" @onclick="() => BpmMultiply(0.5)"><i class="fa-solid fa-divide"></i>2</div>
            </div>

            <div class="key-notation-container">
                <div class="field"
                    tabindex="2"
                    @onblur="@(() => {
                        keysAcVisible = false;
                        player?.EnableMouseEvents = true;
                    })">
                    <label for="key">Key</label>
                    <div
                        class="select-container"
                        @onclick="@(async () => {
                            keysAcVisible = true;
                            player?.EnableMouseEvents = false;
                            await JS.InvokeVoidAsync("scrollToSelectedItem");
                        })">
                        <InputText
                            id="key"
                            class="as-number"
                            ReadOnly="true"
                            @bind-value="FileKeyInSelectedNotation"
                        />
                        <div class="autocomplete scroller @(keysAcVisible ? "show" : "")">
                            @foreach(var key in KeyTools.NotationToKeysMap[selectedNotation]) {
                                <div
                                    class="item @(key == keyTools.ConvertTo(File.Key, selectedNotation) ? "selected" : "")"
                                    @onclick:stopPropagation="true"
                                    @onclick="@(async () => {
                                            File.Key = key;
                                            keysAcVisible = false;
                                            player?.EnableMouseEvents = true;
                                        })">
                                    @key
                                </div>
                            }
                        </div>
                    </div>
                </div>

                <div class="field"
                    tabindex="3"
                    @onblur="@(() => {
                        notationsAcVisible = false;
                        player?.EnableMouseEvents = true;
                    })">
                    <div
                        class="select-container"
                        @onclick="@(async () => {
                            notationsAcVisible = true;
                            player?.EnableMouseEvents = false;
                            await JS.InvokeVoidAsync("scrollToSelectedItem");
                        })">
                        <InputText
                            id="notation"
                            ReadOnly="true"
                            @bind-value="NotationAsString"
                        />
                        <div class="autocomplete notation scroller @(notationsAcVisible ? "show" : "")">
                            @foreach(var notation in Enum.GetNames(typeof(KeyTools.Notations))) {
                                <div
                                    class="item @(notation == NotationAsString ? "selected" : "")"
                                    @onclick:stopPropagation="true"
                                    @onclick="@(async () => {
                                        NotationAsString = notation;
                                        notationsAcVisible = false;
                                        player?.EnableMouseEvents = true;
                                    })">
                                    @notation
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <Player
            File="@File"
            Settings="@(new() {
                Name = "Preview",
                Color = "#82871f"
            })"
            MinimalMode="true"
            @ref="player" />
    </div>

    <div class="filename ellipsis">@File.Filename</div>
</ModalDialog>

<script>
    scrollToSelectedItem = () => {
        let el = document.querySelector(".field .show .item.selected");
        if(el === null) {
            window.setTimeout(scrollToSelectedItem, 50);
        } else {
            el.scrollIntoView();
            while(el != null) {
                if(el.classList.contains("field")) {
                    el.focus();
                    break;
                }
                el = el.parentElement;
            }
        }
    }
</script>

@code {
    private ModalDialog dialog = default!;
    private Player? player = default!;

    // TODO: This autocomplete thing is not working correctly. We need to create a separate component to handle it.
    private bool albumsAcVisible = false;
    private bool genresAcVisible = false;
    private bool keysAcVisible = false;
    private bool notationsAcVisible = false;

    private List<string> genres = [];
    private List<string> albums = [];
    private List<string> keys = [];

    private KeyTools keyTools = new();
    private KeyTools.Notations selectedNotation = Program.Settings.KeyNotation;

    private int lastHrValue;
    private int lastMinValue;
    private int lastSecValue;
    private int lastMsValue;

    [Parameter]
    public Files FilesComponent { get; set; } = null!;

    [Parameter]
    public EventCallback OnClose { get; set; } = default!;

    [Parameter]
    public DFile File { get; set; } = default!;

    public bool IsOpen { get => dialog.IsOpen; }

    private async Task Save() {
        await FilesComponent.UpdateFile(File);
        Close();
    }

    public void Close() {
        player!.Stop(false);
        player!.EnableMouseEvents = true;
        genresAcVisible = false;
        albumsAcVisible = false;

        OnClose.InvokeAsync();
    }

    private int DownbeatAtHours {
        get => int.Parse(DFile.FormatTime(File.DownbeatAt, true).Split(':')[0]);
        set {
            if(lastHrValue == value) return;
            lastHrValue = value;
            File.DownbeatAt = DFile.ParseTime(value, DownbeatAtMinutes, DownbeatAtSeconds, DownbeatAtMilliSeconds);
            player!.SetParameters();
        }
    }

    private int DownbeatAtMinutes {
        get => int.Parse(DFile.FormatTime(File.DownbeatAt, true).Split(':')[1]);
        set {
            if(lastMinValue == value) return;
            lastMinValue = value;
            File.DownbeatAt = DFile.ParseTime(DownbeatAtHours, value, DownbeatAtSeconds, DownbeatAtMilliSeconds);
            player!.SetParameters();
        }
    }

    private int DownbeatAtSeconds {
        get => int.Parse(DFile.FormatTime(File.DownbeatAt, true).Split(':')[2].Split('.')[0]);
        set {
            if(lastSecValue == value) return;
            lastSecValue = value;
            File.DownbeatAt = DFile.ParseTime(DownbeatAtHours, DownbeatAtMinutes, value, DownbeatAtMilliSeconds);
            player!.SetParameters();
        }
    }

    private int DownbeatAtMilliSeconds {
        get => int.Parse(DFile.FormatTime(File.DownbeatAt, true).Split(':')[2].Split('.')[1]);
        set {
            if(lastMsValue == value) return;
            lastMsValue = value;
            File.DownbeatAt = DFile.ParseTime(DownbeatAtHours, DownbeatAtMinutes, DownbeatAtSeconds, value);
            player!.SetParameters();
        }
    }

    private float BPM {
        get => File.BPM;
        set {
            File.BPM = value;
            player!.SetParameters();
        }
    }

    private async void ReCalcBpm() {
        BPM = FilesComponent.CalcBpm(File);
        await InvokeAsync(StateHasChanged);
    }

    private async void ReCalcDownbeat() {
        File.DownbeatAt = FilesComponent.CalcDownbeat(File);
        await InvokeAsync(StateHasChanged);
    }

    private void ReSetDownbeat() {
        File.DownbeatAt = player!.PlaybackHead / 100.0;
        player!.SetParameters();
    }

    private async void BpmMultiply(double factor) {
        BPM *= (float)factor;
        await InvokeAsync(StateHasChanged);
    }

    private string NotationAsString {
        get => selectedNotation.ToString();
        set {
            if(!Enum.TryParse(value, out KeyTools.Notations result)) return;
            selectedNotation = result;
        }
    }

    private string FileKeyInSelectedNotation {
        get => keyTools.ConvertTo(File.Key, selectedNotation);
        set => File.Key = value;
    }

    protected override void OnAfterRender(bool firstRender) {
        if(firstRender) {
            lastHrValue = -1;
            lastMinValue = -1;
            lastSecValue = -1;
            lastMsValue = -1;

            Task.Run(async () => {
                CacheDbContext? cache = await CacheDbContextFactory.CreateDbContextAsync();
                genres = cache.Files.Select(f => f.Genre).Where(f => f != "").Distinct().OrderBy(f => f).ToList();
                albums = cache.Files.Select(f => f.Album).Where(f => f != "").Distinct().OrderBy(f => f).ToList();

                while(player == null) await Task.Delay(60);

                player.WaveformBarWidth = Program.Settings.Playback.WaveformZoom;
                dialog.Open();
            });
        }

        base.OnAfterRender(firstRender);
    }
}