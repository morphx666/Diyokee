@using Newtonsoft.Json
@inject IJSRuntime JS

<MouseSupport OnMouseEvent="@HandleMouseEvent">
    <div class="panel-resize @(Orientation == Orientations.Horizontal ? "horizontal-resize" : "vertical-resize")" @ref="dividerElement"></div>
</MouseSupport>

@code {
    public enum Orientations {
        Horizontal,
        Vertical
    }

    public enum ConstrainKeys {
        Min,
        Max
    }

    [Parameter]
    public Orientations Orientation { get; set; } = Orientations.Horizontal;

    [Parameter]
    public ElementReference ResizeElement { get; set; }

    [Parameter]
    public string Name { get; set; } = string.Empty;

    [Parameter]
    public List<ElementReference> ElementsBetween { get; set; } = new();

    [Parameter]
    public Dictionary<ConstrainKeys, string> Constrains { get; set; } = new();

    [Parameter]
    public EventCallback<(string, double)> OnResizeEnd { get; set; }

    [CascadingParameter]
    private MouseState mouseState { get; set; } = default!;

    private ElementReference dividerElement;
    private Bounds? dividerBounds;
    private Bounds? resizeElementBounds = default!;
    private double elementsBetweenOffset = 0;

    private bool retry = false;

    private async Task ApplyNewSize() {
        foreach(var constrain in Constrains) {
            if(!double.TryParse(constrain.Value, out double value)) return;
            switch(constrain.Key) {
                case ConstrainKeys.Min:
                    if(Orientation == Orientations.Vertical) {
                        if(resizeElementBounds!.Height < value) {
                            resizeElementBounds.Height = value;
                            dividerBounds!.Y = value + dividerBounds.Height / 2;
                        }
                    } else {
                        if(resizeElementBounds!.Width < value) {
                            resizeElementBounds.Width = value;
                            dividerBounds!.X = value + dividerBounds.Width / 2;
                        }
                    }
                    break;
                case ConstrainKeys.Max:
                    if(Orientation == Orientations.Vertical) {
                        if(resizeElementBounds!.Height > value) {
                            resizeElementBounds.Height = value;
                            dividerBounds!.Y = value + dividerBounds.Height / 2;
                        }
                    } else {
                        if(resizeElementBounds!.Width > value) {
                            resizeElementBounds.Width = value;
                            dividerBounds!.X = value + dividerBounds.Width / 2;
                        }
                    }
                    break;
            }
        }

        if(Orientation == Orientations.Vertical) {
            await JS.InvokeVoidAsync("setElementBounds", ResizeElement, new double[] {
                -1, -1, -1, resizeElementBounds!.Height
        });
        } else {
            await JS.InvokeVoidAsync("setElementBounds", ResizeElement, new double[] {
                -1, -1, resizeElementBounds!.Width, -1
        });
        }

        await Task.Delay(250);
        await JS.InvokeVoidAsync("forceRefresh");
    }

    [JSInvokable]
    public async Task OnResize() {
        await Task.Delay(750);
        dividerBounds = new(await JS.InvokeAsync<double[]>("getElementBounds", dividerElement));
        resizeElementBounds = new(await JS.InvokeAsync<double[]>("getElementBounds", ResizeElement));
        elementsBetweenOffset = 0;
        foreach(var element in ElementsBetween) {
            var b = await JS.InvokeAsync<double[]>("getElementBounds", element);
            elementsBetweenOffset += (double)(await JS.InvokeAsync<double[]>("getElementBounds", element))[Orientation == Orientations.Horizontal ? 2 : 3];
        }
    }

    private async Task HandleMouseEvent() {
        if(Orientation == Orientations.Vertical) {
            resizeElementBounds!.Height = mouseState.Y - elementsBetweenOffset;
            dividerBounds!.Y = resizeElementBounds!.Height + dividerBounds.Height / 2;
        } else {
            resizeElementBounds!.Width = mouseState.X - elementsBetweenOffset;
            dividerBounds!.X = resizeElementBounds!.Width + dividerBounds.Width / 2;
        }
        await ApplyNewSize();

        if(mouseState.ButtonsDown == -1) {
            if(Orientation == Orientations.Vertical) {
                await OnResizeEnd.InvokeAsync((Name, resizeElementBounds!.Height));
            } else {
                await OnResizeEnd.InvokeAsync((Name, resizeElementBounds!.Width));
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender || retry) {
            if(ResizeElement.Id == null) {
                retry = true;
                return;
            } else {
                retry = false;
            }

            await OnResize();
            if(resizeElementBounds?.Width == 0 || resizeElementBounds?.Height == 0) return;

            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("Diyokee.monitorResize", dotNetReference);

            if(Program.Settings.UIElements.ContainsKey(Name)) {
                if(double.TryParse(Program.Settings.UIElements[Name], out double value) && resizeElementBounds != null) {
                    if(Orientation == Orientations.Vertical) {
                        resizeElementBounds.Height = value;
                        dividerBounds!.Y = value;
                    } else {
                        resizeElementBounds.Width = value;
                        dividerBounds!.X = value;
                    }

                    await ApplyNewSize();
                }
            }
        }
    }
}
